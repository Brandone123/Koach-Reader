{"ast":null,"code":"import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { fetchApi } from '../utils/api';\nimport { mockFetchApi } from '../utils/mockApi';\nconst initialState = {\n  challenges: [],\n  userChallenges: [],\n  currentChallenge: null,\n  participants: [],\n  comments: [],\n  isLoading: false,\n  error: null\n};\nexport const fetchChallenges = createAsyncThunk('challenges/fetchChallenges', async (_, {\n  rejectWithValue\n}) => {\n  try {\n    const data = await fetchApi('/api/challenges');\n    return data;\n  } catch (error) {\n    try {\n      const mockData = await mockFetchApi('/api/challenges');\n      return mockData;\n    } catch (mockError) {\n      return rejectWithValue(mockError.message || 'Failed to fetch challenges');\n    }\n  }\n});\nexport const fetchUserChallenges = createAsyncThunk('challenges/fetchUserChallenges', async (_, {\n  rejectWithValue\n}) => {\n  try {\n    const data = await fetchApi('/api/user/challenges');\n    return data;\n  } catch (error) {\n    try {\n      const mockData = await mockFetchApi('/api/challenges');\n      return mockData.filter(challenge => challenge.myProgress !== undefined);\n    } catch (mockError) {\n      return rejectWithValue(mockError.message || 'Failed to fetch user challenges');\n    }\n  }\n});\nexport const fetchChallengeById = createAsyncThunk('challenges/fetchChallengeById', async (challengeId, {\n  rejectWithValue\n}) => {\n  try {\n    const data = await fetchApi(`/api/challenges/${challengeId}`);\n    return data;\n  } catch (error) {\n    try {\n      const mockData = await mockFetchApi(`/api/challenges/${challengeId}`);\n      return mockData;\n    } catch (mockError) {\n      return rejectWithValue(mockError.message || 'Failed to fetch challenge details');\n    }\n  }\n});\nexport const fetchChallengeParticipants = createAsyncThunk('challenges/fetchChallengeParticipants', async (challengeId, {\n  rejectWithValue\n}) => {\n  try {\n    const data = await fetchApi(`/api/challenges/${challengeId}/participants`);\n    return data;\n  } catch (error) {\n    try {\n      const mockData = await mockFetchApi(`/api/challenges/${challengeId}/participants`);\n      return mockData;\n    } catch (mockError) {\n      return rejectWithValue(mockError.message || 'Failed to fetch challenge participants');\n    }\n  }\n});\nexport const fetchChallengeComments = createAsyncThunk('challenges/fetchChallengeComments', async (challengeId, {\n  rejectWithValue\n}) => {\n  try {\n    const data = await fetchApi(`/api/challenges/${challengeId}/comments`);\n    return data;\n  } catch (error) {\n    try {\n      const mockData = await mockFetchApi(`/api/challenges/${challengeId}/comments`);\n      return mockData;\n    } catch (mockError) {\n      return rejectWithValue(mockError.message || 'Failed to fetch challenge comments');\n    }\n  }\n});\nexport const joinChallenge = createAsyncThunk('challenges/joinChallenge', async (challengeId, {\n  rejectWithValue\n}) => {\n  try {\n    const response = await fetchApi(`/api/challenges/${challengeId}/join`, {\n      method: 'POST'\n    });\n    return Object.assign({}, response, {\n      challengeId\n    });\n  } catch (error) {\n    try {\n      const mockResponse = await mockFetchApi(`/api/challenges/${challengeId}/join`, {\n        method: 'POST'\n      });\n      return Object.assign({}, mockResponse, {\n        challengeId\n      });\n    } catch (mockError) {\n      return rejectWithValue(mockError.message || 'Failed to join challenge');\n    }\n  }\n});\nexport const updateChallengeProgress = createAsyncThunk('challenges/updateChallengeProgress', async ({\n  challengeId,\n  progress\n}, {\n  rejectWithValue\n}) => {\n  try {\n    const response = await fetchApi(`/api/challenges/${challengeId}/progress`, {\n      method: 'POST',\n      body: {\n        progress\n      }\n    });\n    return Object.assign({}, response, {\n      challengeId,\n      progress\n    });\n  } catch (error) {\n    try {\n      const mockResponse = await mockFetchApi(`/api/challenges/${challengeId}/progress`, {\n        method: 'POST',\n        body: {\n          progress\n        }\n      });\n      return Object.assign({}, mockResponse, {\n        challengeId,\n        progress\n      });\n    } catch (mockError) {\n      return rejectWithValue(mockError.message || 'Failed to update challenge progress');\n    }\n  }\n});\nexport const createChallenge = createAsyncThunk('challenges/createChallenge', async (challengeData, {\n  rejectWithValue\n}) => {\n  try {\n    const response = await fetchApi('/api/challenges', {\n      method: 'POST',\n      body: challengeData\n    });\n    return response;\n  } catch (error) {\n    try {\n      const mockResponse = await mockFetchApi('/api/challenges', {\n        method: 'POST',\n        body: challengeData\n      });\n      return mockResponse;\n    } catch (mockError) {\n      return rejectWithValue(mockError.message || 'Failed to create challenge');\n    }\n  }\n});\nexport const addChallengeComment = createAsyncThunk('challenges/addChallengeComment', async ({\n  challengeId,\n  content\n}, {\n  rejectWithValue\n}) => {\n  try {\n    const response = await fetchApi(`/api/challenges/${challengeId}/comments`, {\n      method: 'POST',\n      body: {\n        content\n      }\n    });\n    return response;\n  } catch (error) {\n    try {\n      const mockResponse = await mockFetchApi(`/api/challenges/${challengeId}/comments`, {\n        method: 'POST',\n        body: {\n          content\n        }\n      });\n      return mockResponse;\n    } catch (mockError) {\n      return rejectWithValue(mockError.message || 'Failed to add comment');\n    }\n  }\n});\nconst challengesSlice = createSlice({\n  name: 'challenges',\n  initialState,\n  reducers: {\n    clearCurrentChallenge: state => {\n      state.currentChallenge = null;\n      state.participants = [];\n      state.comments = [];\n    }\n  },\n  extraReducers: builder => {\n    builder.addCase(fetchChallenges.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(fetchChallenges.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.challenges = action.payload;\n    }).addCase(fetchChallenges.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload || 'Failed to fetch challenges';\n    }).addCase(fetchUserChallenges.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(fetchUserChallenges.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.userChallenges = action.payload;\n    }).addCase(fetchUserChallenges.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload || 'Failed to fetch user challenges';\n    }).addCase(fetchChallengeById.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(fetchChallengeById.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.currentChallenge = action.payload;\n    }).addCase(fetchChallengeById.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload || 'Failed to fetch challenge details';\n    }).addCase(fetchChallengeParticipants.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(fetchChallengeParticipants.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.participants = action.payload;\n    }).addCase(fetchChallengeParticipants.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload || 'Failed to fetch challenge participants';\n    }).addCase(fetchChallengeComments.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(fetchChallengeComments.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.comments = action.payload;\n    }).addCase(fetchChallengeComments.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload || 'Failed to fetch challenge comments';\n    }).addCase(joinChallenge.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(joinChallenge.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.challenges = state.challenges.map(challenge => challenge.id === action.payload.challengeId ? Object.assign({}, challenge, {\n        status: 'active',\n        myProgress: 0\n      }) : challenge);\n      if (!state.userChallenges.some(c => c.id === action.payload.challengeId)) {\n        const challenge = state.challenges.find(c => c.id === action.payload.challengeId);\n        if (challenge) {\n          state.userChallenges.push(Object.assign({}, challenge, {\n            status: 'active',\n            myProgress: 0\n          }));\n        }\n      }\n      if (state.currentChallenge && state.currentChallenge.id === action.payload.challengeId) {\n        state.currentChallenge = Object.assign({}, state.currentChallenge, {\n          status: 'active',\n          myProgress: 0\n        });\n      }\n    }).addCase(joinChallenge.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload || 'Failed to join challenge';\n    }).addCase(updateChallengeProgress.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(updateChallengeProgress.fulfilled, (state, action) => {\n      state.isLoading = false;\n      const {\n        challengeId,\n        progress\n      } = action.payload;\n      const status = progress >= (state.currentChallenge?.goal || 0) ? 'completed' : 'active';\n      state.challenges = state.challenges.map(challenge => challenge.id === challengeId ? Object.assign({}, challenge, {\n        myProgress: progress,\n        status\n      }) : challenge);\n      state.userChallenges = state.userChallenges.map(challenge => challenge.id === challengeId ? Object.assign({}, challenge, {\n        myProgress: progress,\n        status\n      }) : challenge);\n      if (state.currentChallenge && state.currentChallenge.id === challengeId) {\n        state.currentChallenge = Object.assign({}, state.currentChallenge, {\n          myProgress: progress,\n          status\n        });\n      }\n      const currentUserId = state.participants.find(p => p.status === 'active')?.userId;\n      if (currentUserId) {\n        state.participants = state.participants.map(participant => {\n          if (participant.userId === currentUserId) {\n            return Object.assign({}, participant, {\n              progress,\n              status\n            });\n          }\n          return participant;\n        });\n      }\n    }).addCase(updateChallengeProgress.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload || 'Failed to update challenge progress';\n    }).addCase(createChallenge.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(createChallenge.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.challenges.push(action.payload);\n      state.userChallenges.push(action.payload);\n    }).addCase(createChallenge.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload || 'Failed to create challenge';\n    }).addCase(addChallengeComment.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(addChallengeComment.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.comments.unshift(action.payload);\n    }).addCase(addChallengeComment.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload || 'Failed to add comment';\n    });\n  }\n});\nexport const {\n  clearCurrentChallenge\n} = challengesSlice.actions;\nexport const selectAllChallenges = state => state.challenges.challenges;\nexport const selectUserChallenges = state => state.challenges.userChallenges;\nexport const selectCurrentChallenge = state => state.challenges.currentChallenge;\nexport const selectChallengeParticipants = state => state.challenges.participants;\nexport const selectChallengeComments = state => state.challenges.comments;\nexport const selectChallengesLoading = state => state.challenges.isLoading;\nexport const selectChallengesError = state => state.challenges.error;\nexport default challengesSlice.reducer;","map":{"version":3,"names":["createSlice","createAsyncThunk","fetchApi","mockFetchApi","initialState","challenges","userChallenges","currentChallenge","participants","comments","isLoading","error","fetchChallenges","_","rejectWithValue","data","mockData","mockError","message","fetchUserChallenges","filter","challenge","myProgress","undefined","fetchChallengeById","challengeId","fetchChallengeParticipants","fetchChallengeComments","joinChallenge","response","method","Object","assign","mockResponse","updateChallengeProgress","progress","body","createChallenge","challengeData","addChallengeComment","content","challengesSlice","name","reducers","clearCurrentChallenge","state","extraReducers","builder","addCase","pending","fulfilled","action","payload","rejected","map","id","status","some","c","find","push","goal","currentUserId","p","userId","participant","unshift","actions","selectAllChallenges","selectUserChallenges","selectCurrentChallenge","selectChallengeParticipants","selectChallengeComments","selectChallengesLoading","selectChallengesError","reducer"],"sources":["D:/All_Projects/KoachReadsFinal/client/src/slices/challengesSlice.ts"],"sourcesContent":["import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';\nimport { RootState } from '../store';\nimport { fetchApi } from '../utils/api';\nimport { mockFetchApi } from '../utils/mockApi';\n\nexport interface Challenge {\n  id: number;\n  title: string;\n  description: string;\n  creatorId: number;\n  startDate: string;\n  endDate: string;\n  goal: number;\n  goalType: 'pages' | 'books' | 'minutes';\n  bookId?: number;\n  categoryId?: number;\n  isPrivate: boolean;\n  participantCount: number;\n  myProgress?: number;\n  status?: 'active' | 'completed' | 'abandoned';\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport interface ChallengeParticipant {\n  id: number;\n  challengeId: number;\n  userId: number;\n  progress: number;\n  status: 'active' | 'completed' | 'abandoned';\n  username: string;\n  joinedAt: string;\n}\n\nexport interface ChallengeComment {\n  id: number;\n  challengeId: number;\n  userId: number;\n  username: string;\n  content: string;\n  createdAt: string;\n}\n\ninterface ChallengesState {\n  challenges: Challenge[];\n  userChallenges: Challenge[];\n  currentChallenge: Challenge | null;\n  participants: ChallengeParticipant[];\n  comments: ChallengeComment[];\n  isLoading: boolean;\n  error: string | null;\n}\n\nconst initialState: ChallengesState = {\n  challenges: [],\n  userChallenges: [],\n  currentChallenge: null,\n  participants: [],\n  comments: [],\n  isLoading: false,\n  error: null,\n};\n\n// Fetch all challenges\nexport const fetchChallenges = createAsyncThunk(\n  'challenges/fetchChallenges',\n  async (_, { rejectWithValue }) => {\n    try {\n      // Try to fetch from real API\n      const data = await fetchApi('/api/challenges');\n      return data;\n    } catch (error) {\n      try {\n        // Fall back to mock API\n        const mockData = await mockFetchApi('/api/challenges');\n        return mockData;\n      } catch (mockError: any) {\n        return rejectWithValue(mockError.message || 'Failed to fetch challenges');\n      }\n    }\n  }\n);\n\n// Fetch challenges the user is participating in\nexport const fetchUserChallenges = createAsyncThunk(\n  'challenges/fetchUserChallenges',\n  async (_, { rejectWithValue }) => {\n    try {\n      // Try to fetch from real API\n      const data = await fetchApi('/api/user/challenges');\n      return data;\n    } catch (error) {\n      try {\n        // Fall back to mock API\n        // In the mock scenario, we'll filter challenges with myProgress defined\n        const mockData = await mockFetchApi('/api/challenges');\n        return mockData.filter((challenge: any) => challenge.myProgress !== undefined);\n      } catch (mockError: any) {\n        return rejectWithValue(mockError.message || 'Failed to fetch user challenges');\n      }\n    }\n  }\n);\n\n// Fetch challenge details by ID\nexport const fetchChallengeById = createAsyncThunk(\n  'challenges/fetchChallengeById',\n  async (challengeId: number, { rejectWithValue }) => {\n    try {\n      // Try to fetch from real API\n      const data = await fetchApi(`/api/challenges/${challengeId}`);\n      return data;\n    } catch (error) {\n      try {\n        // Fall back to mock API\n        const mockData = await mockFetchApi(`/api/challenges/${challengeId}`);\n        return mockData;\n      } catch (mockError: any) {\n        return rejectWithValue(mockError.message || 'Failed to fetch challenge details');\n      }\n    }\n  }\n);\n\n// Fetch challenge participants\nexport const fetchChallengeParticipants = createAsyncThunk(\n  'challenges/fetchChallengeParticipants',\n  async (challengeId: number, { rejectWithValue }) => {\n    try {\n      // Try to fetch from real API\n      const data = await fetchApi(`/api/challenges/${challengeId}/participants`);\n      return data;\n    } catch (error) {\n      try {\n        // Fall back to mock API\n        const mockData = await mockFetchApi(`/api/challenges/${challengeId}/participants`);\n        return mockData;\n      } catch (mockError: any) {\n        return rejectWithValue(mockError.message || 'Failed to fetch challenge participants');\n      }\n    }\n  }\n);\n\n// Fetch challenge comments\nexport const fetchChallengeComments = createAsyncThunk(\n  'challenges/fetchChallengeComments',\n  async (challengeId: number, { rejectWithValue }) => {\n    try {\n      // Try to fetch from real API\n      const data = await fetchApi(`/api/challenges/${challengeId}/comments`);\n      return data;\n    } catch (error) {\n      try {\n        // Fall back to mock API\n        const mockData = await mockFetchApi(`/api/challenges/${challengeId}/comments`);\n        return mockData;\n      } catch (mockError: any) {\n        return rejectWithValue(mockError.message || 'Failed to fetch challenge comments');\n      }\n    }\n  }\n);\n\n// Join a challenge\nexport const joinChallenge = createAsyncThunk(\n  'challenges/joinChallenge',\n  async (challengeId: number, { rejectWithValue }) => {\n    try {\n      // Try to use real API\n      const response = await fetchApi(`/api/challenges/${challengeId}/join`, {\n        method: 'POST'\n      });\n      return { ...response, challengeId };\n    } catch (error) {\n      try {\n        // Fall back to mock API\n        const mockResponse = await mockFetchApi(`/api/challenges/${challengeId}/join`, {\n          method: 'POST'\n        });\n        return { ...mockResponse, challengeId };\n      } catch (mockError: any) {\n        return rejectWithValue(mockError.message || 'Failed to join challenge');\n      }\n    }\n  }\n);\n\n// Update challenge progress\nexport const updateChallengeProgress = createAsyncThunk(\n  'challenges/updateChallengeProgress',\n  async ({ challengeId, progress }: { challengeId: number; progress: number }, { rejectWithValue }) => {\n    try {\n      // Try to use real API\n      const response = await fetchApi(`/api/challenges/${challengeId}/progress`, {\n        method: 'POST',\n        body: { progress }\n      });\n      return { ...response, challengeId, progress };\n    } catch (error) {\n      try {\n        // Fall back to mock API\n        const mockResponse = await mockFetchApi(`/api/challenges/${challengeId}/progress`, {\n          method: 'POST',\n          body: { progress }\n        });\n        return { ...mockResponse, challengeId, progress };\n      } catch (mockError: any) {\n        return rejectWithValue(mockError.message || 'Failed to update challenge progress');\n      }\n    }\n  }\n);\n\n// Create a new challenge\nexport const createChallenge = createAsyncThunk(\n  'challenges/createChallenge',\n  async (challengeData: Omit<Challenge, 'id' | 'participantCount' | 'createdAt' | 'updatedAt'>, { rejectWithValue }) => {\n    try {\n      // Try to use real API\n      const response = await fetchApi('/api/challenges', {\n        method: 'POST',\n        body: challengeData\n      });\n      return response;\n    } catch (error) {\n      try {\n        // Fall back to mock API\n        const mockResponse = await mockFetchApi('/api/challenges', {\n          method: 'POST',\n          body: challengeData\n        });\n        return mockResponse;\n      } catch (mockError: any) {\n        return rejectWithValue(mockError.message || 'Failed to create challenge');\n      }\n    }\n  }\n);\n\n// Add a comment to a challenge\nexport const addChallengeComment = createAsyncThunk(\n  'challenges/addChallengeComment',\n  async ({ challengeId, content }: { challengeId: number; content: string }, { rejectWithValue }) => {\n    try {\n      // Try to use real API\n      const response = await fetchApi(`/api/challenges/${challengeId}/comments`, {\n        method: 'POST',\n        body: { content }\n      });\n      return response;\n    } catch (error) {\n      try {\n        // Fall back to mock API\n        const mockResponse = await mockFetchApi(`/api/challenges/${challengeId}/comments`, {\n          method: 'POST',\n          body: { content }\n        });\n        return mockResponse;\n      } catch (mockError: any) {\n        return rejectWithValue(mockError.message || 'Failed to add comment');\n      }\n    }\n  }\n);\n\nconst challengesSlice = createSlice({\n  name: 'challenges',\n  initialState,\n  reducers: {\n    clearCurrentChallenge: (state) => {\n      state.currentChallenge = null;\n      state.participants = [];\n      state.comments = [];\n    }\n  },\n  extraReducers: (builder) => {\n    builder\n      // Fetch Challenges\n      .addCase(fetchChallenges.pending, (state) => {\n        state.isLoading = true;\n        state.error = null;\n      })\n      .addCase(fetchChallenges.fulfilled, (state, action: PayloadAction<Challenge[]>) => {\n        state.isLoading = false;\n        state.challenges = action.payload;\n      })\n      .addCase(fetchChallenges.rejected, (state, action) => {\n        state.isLoading = false;\n        state.error = action.payload as string || 'Failed to fetch challenges';\n      })\n\n      // Fetch User Challenges\n      .addCase(fetchUserChallenges.pending, (state) => {\n        state.isLoading = true;\n        state.error = null;\n      })\n      .addCase(fetchUserChallenges.fulfilled, (state, action: PayloadAction<Challenge[]>) => {\n        state.isLoading = false;\n        state.userChallenges = action.payload;\n      })\n      .addCase(fetchUserChallenges.rejected, (state, action) => {\n        state.isLoading = false;\n        state.error = action.payload as string || 'Failed to fetch user challenges';\n      })\n\n      // Fetch Challenge By ID\n      .addCase(fetchChallengeById.pending, (state) => {\n        state.isLoading = true;\n        state.error = null;\n      })\n      .addCase(fetchChallengeById.fulfilled, (state, action: PayloadAction<Challenge>) => {\n        state.isLoading = false;\n        state.currentChallenge = action.payload;\n      })\n      .addCase(fetchChallengeById.rejected, (state, action) => {\n        state.isLoading = false;\n        state.error = action.payload as string || 'Failed to fetch challenge details';\n      })\n\n      // Fetch Challenge Participants\n      .addCase(fetchChallengeParticipants.pending, (state) => {\n        state.isLoading = true;\n        state.error = null;\n      })\n      .addCase(fetchChallengeParticipants.fulfilled, (state, action: PayloadAction<ChallengeParticipant[]>) => {\n        state.isLoading = false;\n        state.participants = action.payload;\n      })\n      .addCase(fetchChallengeParticipants.rejected, (state, action) => {\n        state.isLoading = false;\n        state.error = action.payload as string || 'Failed to fetch challenge participants';\n      })\n      \n      // Fetch Challenge Comments\n      .addCase(fetchChallengeComments.pending, (state) => {\n        state.isLoading = true;\n        state.error = null;\n      })\n      .addCase(fetchChallengeComments.fulfilled, (state, action: PayloadAction<ChallengeComment[]>) => {\n        state.isLoading = false;\n        state.comments = action.payload;\n      })\n      .addCase(fetchChallengeComments.rejected, (state, action) => {\n        state.isLoading = false;\n        state.error = action.payload as string || 'Failed to fetch challenge comments';\n      })\n\n      // Join Challenge\n      .addCase(joinChallenge.pending, (state) => {\n        state.isLoading = true;\n        state.error = null;\n      })\n      .addCase(joinChallenge.fulfilled, (state, action) => {\n        state.isLoading = false;\n        // Update the challenge in challenges list with new status\n        state.challenges = state.challenges.map(challenge => \n          challenge.id === action.payload.challengeId\n            ? { ...challenge, status: 'active' as const, myProgress: 0 }\n            : challenge\n        );\n        // Add to user challenges if not already there\n        if (!state.userChallenges.some(c => c.id === action.payload.challengeId)) {\n          const challenge = state.challenges.find(c => c.id === action.payload.challengeId);\n          if (challenge) {\n            state.userChallenges.push({\n              ...challenge,\n              status: 'active' as const,\n              myProgress: 0\n            });\n          }\n        }\n        // Update current challenge if it's the one being joined\n        if (state.currentChallenge && state.currentChallenge.id === action.payload.challengeId) {\n          state.currentChallenge = {\n            ...state.currentChallenge,\n            status: 'active' as const,\n            myProgress: 0\n          };\n        }\n      })\n      .addCase(joinChallenge.rejected, (state, action) => {\n        state.isLoading = false;\n        state.error = action.payload as string || 'Failed to join challenge';\n      })\n\n      // Update Challenge Progress\n      .addCase(updateChallengeProgress.pending, (state) => {\n        state.isLoading = true;\n        state.error = null;\n      })\n      .addCase(updateChallengeProgress.fulfilled, (state, action) => {\n        state.isLoading = false;\n        const { challengeId, progress } = action.payload;\n        const status = progress >= (state.currentChallenge?.goal || 0) ? 'completed' as const : 'active' as const;\n        \n        // Update in challenges list\n        state.challenges = state.challenges.map(challenge => \n          challenge.id === challengeId\n            ? { ...challenge, myProgress: progress, status }\n            : challenge\n        );\n        \n        // Update in user challenges\n        state.userChallenges = state.userChallenges.map(challenge => \n          challenge.id === challengeId\n            ? { ...challenge, myProgress: progress, status }\n            : challenge\n        );\n        \n        // Update current challenge\n        if (state.currentChallenge && state.currentChallenge.id === challengeId) {\n          state.currentChallenge = {\n            ...state.currentChallenge,\n            myProgress: progress,\n            status\n          };\n        }\n        \n        // Update the current user's entry in participants list\n        const currentUserId = state.participants.find(p => p.status === 'active')?.userId;\n        if (currentUserId) {\n          state.participants = state.participants.map(participant => {\n            if (participant.userId === currentUserId) {\n              return {\n                ...participant,\n                progress,\n                status\n              };\n            }\n            return participant;\n          });\n        }\n      })\n      .addCase(updateChallengeProgress.rejected, (state, action) => {\n        state.isLoading = false;\n        state.error = action.payload as string || 'Failed to update challenge progress';\n      })\n      \n      // Create Challenge\n      .addCase(createChallenge.pending, (state) => {\n        state.isLoading = true;\n        state.error = null;\n      })\n      .addCase(createChallenge.fulfilled, (state, action: PayloadAction<Challenge>) => {\n        state.isLoading = false;\n        state.challenges.push(action.payload);\n        state.userChallenges.push(action.payload);\n      })\n      .addCase(createChallenge.rejected, (state, action) => {\n        state.isLoading = false;\n        state.error = action.payload as string || 'Failed to create challenge';\n      })\n      \n      // Add Challenge Comment\n      .addCase(addChallengeComment.pending, (state) => {\n        state.isLoading = true;\n        state.error = null;\n      })\n      .addCase(addChallengeComment.fulfilled, (state, action: PayloadAction<ChallengeComment>) => {\n        state.isLoading = false;\n        state.comments.unshift(action.payload);\n      })\n      .addCase(addChallengeComment.rejected, (state, action) => {\n        state.isLoading = false;\n        state.error = action.payload as string || 'Failed to add comment';\n      });\n  },\n});\n\nexport const { clearCurrentChallenge } = challengesSlice.actions;\n\n// Selectors\nexport const selectAllChallenges = (state: RootState) => state.challenges.challenges;\nexport const selectUserChallenges = (state: RootState) => state.challenges.userChallenges;\nexport const selectCurrentChallenge = (state: RootState) => state.challenges.currentChallenge;\nexport const selectChallengeParticipants = (state: RootState) => state.challenges.participants;\nexport const selectChallengeComments = (state: RootState) => state.challenges.comments;\nexport const selectChallengesLoading = (state: RootState) => state.challenges.isLoading;\nexport const selectChallengesError = (state: RootState) => state.challenges.error;\n\nexport default challengesSlice.reducer;"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}