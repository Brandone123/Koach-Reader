{"ast":null,"code":"import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\nconst initialState = {\n  user: null,\n  token: null,\n  isLoading: false,\n  error: null\n};\nconst authAPI = {\n  login: async credentials => {\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    if (credentials.username === 'demo' && credentials.password === 'password') {\n      return {\n        user: {\n          id: 1,\n          username: 'demo',\n          email: 'demo@example.com',\n          isPremium: false,\n          koachPoints: 120,\n          readingStreak: 5,\n          preferences: {\n            readingFrequency: 'daily',\n            theme: 'light'\n          },\n          createdAt: new Date().toISOString()\n        },\n        token: 'mock-token-12345'\n      };\n    } else {\n      throw new Error('Invalid credentials');\n    }\n  },\n  register: async userData => {\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    if (userData.username === 'demo') {\n      throw new Error('Username already taken');\n    }\n    return {\n      user: {\n        id: 2,\n        username: userData.username,\n        email: userData.email,\n        isPremium: false,\n        koachPoints: 0,\n        readingStreak: 0,\n        preferences: {\n          readingFrequency: 'daily',\n          theme: 'light'\n        },\n        createdAt: new Date().toISOString()\n      },\n      token: 'mock-token-67890'\n    };\n  },\n  updateProfile: async data => {\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    return {\n      id: 1,\n      username: data.username || 'demo',\n      email: data.email || 'demo@example.com',\n      isPremium: false,\n      koachPoints: 120,\n      readingStreak: 5,\n      preferences: data.preferences || {\n        readingFrequency: 'daily',\n        theme: 'light'\n      },\n      createdAt: new Date().toISOString()\n    };\n  }\n};\nexport const login = createAsyncThunk('auth/login', async (credentials, {\n  rejectWithValue\n}) => {\n  try {\n    const response = await authAPI.login(credentials);\n    return response;\n  } catch (error) {\n    return rejectWithValue(error.message);\n  }\n});\nexport const register = createAsyncThunk('auth/register', async (userData, {\n  rejectWithValue\n}) => {\n  try {\n    const response = await authAPI.register(userData);\n    return response;\n  } catch (error) {\n    return rejectWithValue(error.message);\n  }\n});\nexport const logout = createAsyncThunk('auth/logout', async () => {\n  return null;\n});\nexport const fetchCurrentUser = createAsyncThunk('auth/fetchCurrentUser', async (_, {\n  rejectWithValue\n}) => {\n  try {\n    return {\n      user: {\n        id: 1,\n        username: 'demo',\n        email: 'demo@example.com',\n        isPremium: false,\n        koachPoints: 120,\n        readingStreak: 5,\n        preferences: {\n          readingFrequency: 'daily',\n          theme: 'light'\n        },\n        createdAt: new Date().toISOString()\n      }\n    };\n  } catch (error) {\n    return rejectWithValue(error.message);\n  }\n});\nexport const updateProfile = createAsyncThunk('auth/updateProfile', async (profileData, {\n  rejectWithValue\n}) => {\n  try {\n    const user = await authAPI.updateProfile(profileData);\n    return {\n      user\n    };\n  } catch (error) {\n    return rejectWithValue(error.message);\n  }\n});\nexport const updatePreferences = createAsyncThunk('auth/updatePreferences', async (data, {\n  rejectWithValue\n}) => {\n  try {\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    return data.preferences;\n  } catch (error) {\n    return rejectWithValue(error instanceof Error ? error.message : 'Failed to update preferences');\n  }\n});\nconst authSlice = createSlice({\n  name: 'auth',\n  initialState,\n  reducers: {\n    clearError: state => {\n      state.error = null;\n    }\n  },\n  extraReducers: builder => {\n    builder.addCase(login.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(login.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.user = action.payload.user;\n      state.token = action.payload.token;\n    }).addCase(login.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload || 'Login failed';\n    }).addCase(register.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(register.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.user = action.payload.user;\n      state.token = action.payload.token;\n    }).addCase(register.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload || 'Registration failed';\n    }).addCase(logout.fulfilled, state => {\n      state.user = null;\n      state.token = null;\n    }).addCase(fetchCurrentUser.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(fetchCurrentUser.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.user = action.payload.user;\n    }).addCase(fetchCurrentUser.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload || 'Failed to fetch user';\n    }).addCase(updateProfile.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(updateProfile.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.user = action.payload.user;\n    }).addCase(updateProfile.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload || 'Failed to update profile';\n    }).addCase(updatePreferences.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(updatePreferences.fulfilled, (state, action) => {\n      state.isLoading = false;\n      if (state.user) {\n        state.user.preferences = action.payload;\n      }\n    }).addCase(updatePreferences.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload;\n    });\n  }\n});\nexport const {\n  clearError\n} = authSlice.actions;\nexport const selectUser = state => state.auth.user;\nexport const selectIsLoggedIn = state => !!state.auth.user;\nexport const selectIsLoading = state => state.auth.isLoading;\nexport const selectError = state => state.auth.error;\nexport const selectToken = state => state.auth.token;\nexport default authSlice.reducer;","map":{"version":3,"names":["createAsyncThunk","createSlice","initialState","user","token","isLoading","error","authAPI","login","credentials","Promise","resolve","setTimeout","username","password","id","email","isPremium","koachPoints","readingStreak","preferences","readingFrequency","theme","createdAt","Date","toISOString","Error","register","userData","updateProfile","data","rejectWithValue","response","message","logout","fetchCurrentUser","_","profileData","updatePreferences","authSlice","name","reducers","clearError","state","extraReducers","builder","addCase","pending","fulfilled","action","payload","rejected","actions","selectUser","auth","selectIsLoggedIn","selectIsLoading","selectError","selectToken","reducer"],"sources":["D:/All_Projects/Koach-Reader/client/src/slices/authSlice.ts"],"sourcesContent":["import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { RootState } from '../store';\n\n// Types\ninterface User {\n  id: number;\n  username: string;\n  email: string;\n  isPremium: boolean;\n  koachPoints: number;\n  readingStreak: number;\n  preferences?: {\n    readingFrequency?: 'daily' | 'weekly' | 'monthly';\n    ageRange?: 'child' | 'teen' | 'adult';\n    preferredCategories?: string[];\n    spiritualGoals?: string[];\n    preferredReadingFormat?: 'text' | 'audio';\n    preferredReadingTime?: string;\n    language?: string;\n    theme?: 'light' | 'dark' | 'system';\n  };\n  createdAt: string;\n  hasCompletedOnboarding?: boolean;\n}\n\ninterface AuthState {\n  user: User | null;\n  token: string | null;\n  isLoading: boolean;\n  error: string | null;\n}\n\ninterface LoginCredentials {\n  username: string;\n  password: string;\n}\n\ninterface RegisterData {\n  username: string;\n  email: string;\n  password: string;\n}\n\ninterface UpdateProfileData {\n  username?: string;\n  email?: string;\n  preferences?: User['preferences'];\n}\n\ninterface UpdatePreferencesData {\n  preferences: User['preferences'];\n}\n\n// Initial state\nconst initialState: AuthState = {\n  user: null,\n  token: null,\n  isLoading: false,\n  error: null,\n};\n\n// Mock API functions (to be replaced with real API calls)\nconst authAPI = {\n  login: async (credentials: LoginCredentials): Promise<{ user: User; token: string }> => {\n    // Simulate API call delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    // Simulated API response\n    if (credentials.username === 'demo' && credentials.password === 'password') {\n      return {\n        user: {\n          id: 1,\n          username: 'demo',\n          email: 'demo@example.com',\n          isPremium: false,\n          koachPoints: 120,\n          readingStreak: 5,\n          preferences: {\n            readingFrequency: 'daily',\n            theme: 'light',\n          },\n          createdAt: new Date().toISOString(),\n        },\n        token: 'mock-token-12345',\n      };\n    } else {\n      throw new Error('Invalid credentials');\n    }\n  },\n  \n  register: async (userData: RegisterData): Promise<{ user: User; token: string }> => {\n    // Simulate API call delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    // Check if username is taken (in a real app, this would be a server-side check)\n    if (userData.username === 'demo') {\n      throw new Error('Username already taken');\n    }\n    \n    // Simulated API response\n    return {\n      user: {\n        id: 2,\n        username: userData.username,\n        email: userData.email,\n        isPremium: false,\n        koachPoints: 0,\n        readingStreak: 0,\n        preferences: {\n          readingFrequency: 'daily',\n          theme: 'light',\n        },\n        createdAt: new Date().toISOString(),\n      },\n      token: 'mock-token-67890',\n    };\n  },\n  \n  updateProfile: async (data: UpdateProfileData): Promise<User> => {\n    // Simulate API call delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    // Simulated API response - would update the user based on the provided data\n    return {\n      id: 1,\n      username: data.username || 'demo',\n      email: data.email || 'demo@example.com',\n      isPremium: false,\n      koachPoints: 120,\n      readingStreak: 5,\n      preferences: data.preferences || {\n        readingFrequency: 'daily',\n        theme: 'light',\n      },\n      createdAt: new Date().toISOString(),\n    };\n  },\n};\n\n// Async thunks\nexport const login = createAsyncThunk(\n  'auth/login',\n  async (credentials: LoginCredentials, { rejectWithValue }) => {\n    try {\n      const response = await authAPI.login(credentials);\n      return response;\n    } catch (error: any) {\n      return rejectWithValue(error.message);\n    }\n  }\n);\n\nexport const register = createAsyncThunk(\n  'auth/register',\n  async (userData: RegisterData, { rejectWithValue }) => {\n    try {\n      const response = await authAPI.register(userData);\n      return response;\n    } catch (error: any) {\n      return rejectWithValue(error.message);\n    }\n  }\n);\n\nexport const logout = createAsyncThunk('auth/logout', async () => {\n  // In a real app, you would call an API endpoint to invalidate the token\n  return null;\n});\n\nexport const fetchCurrentUser = createAsyncThunk(\n  'auth/fetchCurrentUser',\n  async (_, { rejectWithValue }) => {\n    try {\n      // In a real app, this would be a fetch to get the current user using the stored token\n      return {\n        user: {\n          id: 1,\n          username: 'demo',\n          email: 'demo@example.com',\n          isPremium: false,\n          koachPoints: 120,\n          readingStreak: 5,\n          preferences: {\n            readingFrequency: 'daily',\n            theme: 'light',\n          },\n          createdAt: new Date().toISOString(),\n        },\n      };\n    } catch (error: any) {\n      return rejectWithValue(error.message);\n    }\n  }\n);\n\nexport const updateProfile = createAsyncThunk(\n  'auth/updateProfile',\n  async (profileData: UpdateProfileData, { rejectWithValue }) => {\n    try {\n      const user = await authAPI.updateProfile(profileData);\n      return { user };\n    } catch (error: any) {\n      return rejectWithValue(error.message);\n    }\n  }\n);\n\nexport const updatePreferences = createAsyncThunk(\n  'auth/updatePreferences',\n  async (data: UpdatePreferencesData, { rejectWithValue }) => {\n    try {\n      // Simulate API call delay\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      \n      // Here you would make an actual API call to update preferences\n      // For now, we'll just return the updated preferences\n      return data.preferences;\n    } catch (error) {\n      return rejectWithValue(error instanceof Error ? error.message : 'Failed to update preferences');\n    }\n  }\n);\n\n// Auth slice\nconst authSlice = createSlice({\n  name: 'auth',\n  initialState,\n  reducers: {\n    // Add any synchronous actions here\n    clearError: (state) => {\n      state.error = null;\n    },\n  },\n  extraReducers: (builder) => {\n    builder\n      // Login\n      .addCase(login.pending, (state) => {\n        state.isLoading = true;\n        state.error = null;\n      })\n      .addCase(login.fulfilled, (state, action: PayloadAction<{ user: User; token: string }>) => {\n        state.isLoading = false;\n        state.user = action.payload.user;\n        state.token = action.payload.token;\n      })\n      .addCase(login.rejected, (state, action) => {\n        state.isLoading = false;\n        state.error = action.payload as string || 'Login failed';\n      })\n      // Register\n      .addCase(register.pending, (state) => {\n        state.isLoading = true;\n        state.error = null;\n      })\n      .addCase(register.fulfilled, (state, action: PayloadAction<{ user: User; token: string }>) => {\n        state.isLoading = false;\n        state.user = action.payload.user;\n        state.token = action.payload.token;\n      })\n      .addCase(register.rejected, (state, action) => {\n        state.isLoading = false;\n        state.error = action.payload as string || 'Registration failed';\n      })\n      // Logout\n      .addCase(logout.fulfilled, (state) => {\n        state.user = null;\n        state.token = null;\n      })\n      // Fetch current user\n      .addCase(fetchCurrentUser.pending, (state) => {\n        state.isLoading = true;\n        state.error = null;\n      })\n      .addCase(fetchCurrentUser.fulfilled, (state, action: PayloadAction<{ user: User }>) => {\n        state.isLoading = false;\n        state.user = action.payload.user;\n      })\n      .addCase(fetchCurrentUser.rejected, (state, action) => {\n        state.isLoading = false;\n        state.error = action.payload as string || 'Failed to fetch user';\n      })\n      // Update profile\n      .addCase(updateProfile.pending, (state) => {\n        state.isLoading = true;\n        state.error = null;\n      })\n      .addCase(updateProfile.fulfilled, (state, action: PayloadAction<{ user: User }>) => {\n        state.isLoading = false;\n        state.user = action.payload.user;\n      })\n      .addCase(updateProfile.rejected, (state, action) => {\n        state.isLoading = false;\n        state.error = action.payload as string || 'Failed to update profile';\n      })\n      // Update preferences\n      .addCase(updatePreferences.pending, (state) => {\n        state.isLoading = true;\n        state.error = null;\n      })\n      .addCase(updatePreferences.fulfilled, (state, action: PayloadAction<User['preferences']>) => {\n        state.isLoading = false;\n        if (state.user) {\n          state.user.preferences = action.payload;\n        }\n      })\n      .addCase(updatePreferences.rejected, (state, action) => {\n        state.isLoading = false;\n        state.error = action.payload as string;\n      });\n  },\n});\n\n// Export actions\nexport const { clearError } = authSlice.actions;\n\n// Export selectors\nexport const selectUser = (state: RootState) => state.auth.user;\nexport const selectIsLoggedIn = (state: RootState) => !!state.auth.user;\nexport const selectIsLoading = (state: RootState) => state.auth.isLoading;\nexport const selectError = (state: RootState) => state.auth.error;\nexport const selectToken = (state: RootState) => state.auth.token;\n\n// Export reducer\nexport default authSlice.reducer;"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}