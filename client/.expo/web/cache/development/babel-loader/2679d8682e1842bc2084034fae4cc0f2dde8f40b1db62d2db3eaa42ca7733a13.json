{"ast":null,"code":"import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nconst initialState = {\n  notifications: [],\n  unreadCount: 0,\n  isLoading: false,\n  error: null\n};\nexport const fetchNotifications = createAsyncThunk('notifications/fetchNotifications', async (_, {\n  rejectWithValue\n}) => {\n  try {\n    const mockNotifications = [{\n      id: 1,\n      userId: 1,\n      type: 'achievement',\n      title: 'Badge Earned!',\n      message: 'You earned the Bookworm badge for reading 7 days in a row!',\n      read: false,\n      data: {\n        badgeId: 1\n      },\n      createdAt: new Date().toISOString()\n    }, {\n      id: 2,\n      userId: 1,\n      type: 'challenge',\n      title: 'Challenge Update',\n      message: 'You\\'re halfway through the Summer Reading Challenge!',\n      read: true,\n      data: {\n        challengeId: 1,\n        progress: 50\n      },\n      createdAt: new Date(Date.now() - 86400000).toISOString()\n    }, {\n      id: 3,\n      userId: 1,\n      type: 'friend',\n      title: 'Friend Request',\n      message: 'User2 sent you a friend request',\n      read: false,\n      data: {\n        friendId: 2,\n        friendUsername: 'User2'\n      },\n      createdAt: new Date(Date.now() - 172800000).toISOString()\n    }, {\n      id: 4,\n      userId: 1,\n      type: 'reading',\n      title: 'Reading Activity',\n      message: 'You read 30 pages of \"The Great Book\"',\n      read: false,\n      data: {\n        bookId: 3,\n        bookTitle: 'The Great Book',\n        pagesRead: 30\n      },\n      createdAt: new Date(Date.now() - 30000).toISOString()\n    }, {\n      id: 5,\n      userId: 1,\n      type: 'reminder',\n      title: 'Reading Reminder',\n      message: 'Time to continue reading \"The Great Book\"',\n      read: false,\n      data: {\n        bookId: 3,\n        bookTitle: 'The Great Book'\n      },\n      createdAt: new Date(Date.now() - 10000).toISOString()\n    }];\n    return mockNotifications;\n  } catch (error) {\n    return rejectWithValue('Failed to fetch notifications.');\n  }\n});\nexport const markNotificationAsRead = createAsyncThunk('notifications/markNotificationAsRead', async (notificationId, {\n  rejectWithValue\n}) => {\n  try {\n    return notificationId;\n  } catch (error) {\n    return rejectWithValue('Failed to mark notification as read.');\n  }\n});\nexport const markAllNotificationsAsRead = createAsyncThunk('notifications/markAllNotificationsAsRead', async (_, {\n  rejectWithValue\n}) => {\n  try {\n    return true;\n  } catch (error) {\n    return rejectWithValue('Failed to mark all notifications as read.');\n  }\n});\nconst notificationsSlice = createSlice({\n  name: 'notifications',\n  initialState,\n  reducers: {\n    addNotification: (state, action) => {\n      state.notifications.unshift(action.payload);\n      state.unreadCount += 1;\n    },\n    clearAllNotifications: state => {\n      state.notifications = [];\n      state.unreadCount = 0;\n    }\n  },\n  extraReducers: builder => {\n    builder.addCase(fetchNotifications.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    });\n    builder.addCase(fetchNotifications.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.notifications = action.payload;\n      state.unreadCount = action.payload.filter(n => !n.read).length;\n    });\n    builder.addCase(fetchNotifications.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload;\n    });\n    builder.addCase(markNotificationAsRead.fulfilled, (state, action) => {\n      const notification = state.notifications.find(n => n.id === action.payload);\n      if (notification && !notification.read) {\n        notification.read = true;\n        state.unreadCount -= 1;\n      }\n    });\n    builder.addCase(markAllNotificationsAsRead.fulfilled, state => {\n      state.notifications.forEach(notification => {\n        notification.read = true;\n      });\n      state.unreadCount = 0;\n    });\n  }\n});\nexport const {\n  addNotification,\n  clearAllNotifications\n} = notificationsSlice.actions;\nexport const selectAllNotifications = state => state.notifications.notifications;\nexport const selectNotifications = state => state.notifications.notifications;\nexport const selectNotificationsLoading = state => state.notifications.isLoading;\nexport const selectUnreadCount = state => state.notifications.unreadCount;\nexport const selectIsLoading = state => state.notifications.isLoading;\nexport const selectError = state => state.notifications.error;\nexport default notificationsSlice.reducer;","map":{"version":3,"names":["createSlice","createAsyncThunk","initialState","notifications","unreadCount","isLoading","error","fetchNotifications","_","rejectWithValue","mockNotifications","id","userId","type","title","message","read","data","badgeId","createdAt","Date","toISOString","challengeId","progress","now","friendId","friendUsername","bookId","bookTitle","pagesRead","markNotificationAsRead","notificationId","markAllNotificationsAsRead","notificationsSlice","name","reducers","addNotification","state","action","unshift","payload","clearAllNotifications","extraReducers","builder","addCase","pending","fulfilled","filter","n","length","rejected","notification","find","forEach","actions","selectAllNotifications","selectNotifications","selectNotificationsLoading","selectUnreadCount","selectIsLoading","selectError","reducer"],"sources":["D:/All_Projects/Koach-Reader/client/src/redux/slices/notificationsSlice.ts"],"sourcesContent":["import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';\nimport { RootState } from '../store';\n\n// Types\nexport interface Notification {\n  id: number;\n  userId: number;\n  type: 'achievement' | 'challenge' | 'friend' | 'reading' | 'system' | 'reminder';\n  title: string;\n  message: string;\n  read: boolean;\n  data?: {\n    [key: string]: any;\n  };\n  createdAt: string;\n}\n\ninterface NotificationsState {\n  notifications: Notification[];\n  unreadCount: number;\n  isLoading: boolean;\n  error: string | null;\n}\n\nconst initialState: NotificationsState = {\n  notifications: [],\n  unreadCount: 0,\n  isLoading: false,\n  error: null,\n};\n\n// Async actions\nexport const fetchNotifications = createAsyncThunk(\n  'notifications/fetchNotifications',\n  async (_, { rejectWithValue }) => {\n    try {\n      // Mock data - will connect to server later\n      const mockNotifications: Notification[] = [\n        {\n          id: 1,\n          userId: 1,\n          type: 'achievement' as const,\n          title: 'Badge Earned!',\n          message: 'You earned the Bookworm badge for reading 7 days in a row!',\n          read: false,\n          data: {\n            badgeId: 1,\n          },\n          createdAt: new Date().toISOString(),\n        },\n        {\n          id: 2,\n          userId: 1,\n          type: 'challenge' as const,\n          title: 'Challenge Update',\n          message: 'You\\'re halfway through the Summer Reading Challenge!',\n          read: true,\n          data: {\n            challengeId: 1,\n            progress: 50,\n          },\n          createdAt: new Date(Date.now() - 86400000).toISOString(), // 1 day ago\n        },\n        {\n          id: 3,\n          userId: 1,\n          type: 'friend' as const,\n          title: 'Friend Request',\n          message: 'User2 sent you a friend request',\n          read: false,\n          data: {\n            friendId: 2,\n            friendUsername: 'User2',\n          },\n          createdAt: new Date(Date.now() - 172800000).toISOString(), // 2 days ago\n        },\n        {\n          id: 4,\n          userId: 1,\n          type: 'reading' as const,\n          title: 'Reading Activity',\n          message: 'You read 30 pages of \"The Great Book\"',\n          read: false,\n          data: {\n            bookId: 3,\n            bookTitle: 'The Great Book',\n            pagesRead: 30\n          },\n          createdAt: new Date(Date.now() - 30000).toISOString(), // 30 seconds ago\n        },\n        {\n          id: 5,\n          userId: 1,\n          type: 'reminder' as const,\n          title: 'Reading Reminder',\n          message: 'Time to continue reading \"The Great Book\"',\n          read: false,\n          data: {\n            bookId: 3,\n            bookTitle: 'The Great Book'\n          },\n          createdAt: new Date(Date.now() - 10000).toISOString(), // 10 seconds ago\n        },\n      ];\n      return mockNotifications;\n    } catch (error) {\n      return rejectWithValue('Failed to fetch notifications.');\n    }\n  }\n);\n\nexport const markNotificationAsRead = createAsyncThunk(\n  'notifications/markNotificationAsRead',\n  async (notificationId: number, { rejectWithValue }) => {\n    try {\n      // Mock API call - will connect to server later\n      return notificationId;\n    } catch (error) {\n      return rejectWithValue('Failed to mark notification as read.');\n    }\n  }\n);\n\nexport const markAllNotificationsAsRead = createAsyncThunk(\n  'notifications/markAllNotificationsAsRead',\n  async (_, { rejectWithValue }) => {\n    try {\n      // Mock API call - will connect to server later\n      return true;\n    } catch (error) {\n      return rejectWithValue('Failed to mark all notifications as read.');\n    }\n  }\n);\n\n// Slice\nconst notificationsSlice = createSlice({\n  name: 'notifications',\n  initialState,\n  reducers: {\n    addNotification: (state, action: PayloadAction<Notification>) => {\n      state.notifications.unshift(action.payload);\n      state.unreadCount += 1;\n    },\n    clearAllNotifications: (state) => {\n      state.notifications = [];\n      state.unreadCount = 0;\n    },\n  },\n  extraReducers: (builder) => {\n    // Fetch Notifications\n    builder.addCase(fetchNotifications.pending, (state) => {\n      state.isLoading = true;\n      state.error = null;\n    });\n    builder.addCase(fetchNotifications.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.notifications = action.payload;\n      state.unreadCount = action.payload.filter((n: Notification) => !n.read).length;\n    });\n    builder.addCase(fetchNotifications.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload as string;\n    });\n\n    // Mark Notification As Read\n    builder.addCase(markNotificationAsRead.fulfilled, (state, action) => {\n      const notification = state.notifications.find((n) => n.id === action.payload);\n      if (notification && !notification.read) {\n        notification.read = true;\n        state.unreadCount -= 1;\n      }\n    });\n\n    // Mark All Notifications As Read\n    builder.addCase(markAllNotificationsAsRead.fulfilled, (state) => {\n      state.notifications.forEach((notification) => {\n        notification.read = true;\n      });\n      state.unreadCount = 0;\n    });\n  },\n});\n\n// Actions\nexport const { addNotification, clearAllNotifications } = notificationsSlice.actions;\n\n// Selectors\nexport const selectAllNotifications = (state: RootState) => state.notifications.notifications;\nexport const selectNotifications = (state: RootState) => state.notifications.notifications;\nexport const selectNotificationsLoading = (state: RootState) => state.notifications.isLoading;\nexport const selectUnreadCount = (state: RootState) => state.notifications.unreadCount;\nexport const selectIsLoading = (state: RootState) => state.notifications.isLoading;\nexport const selectError = (state: RootState) => state.notifications.error;\n\nexport default notificationsSlice.reducer;"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}