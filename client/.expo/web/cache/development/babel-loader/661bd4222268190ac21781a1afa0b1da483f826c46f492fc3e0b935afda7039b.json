{"ast":null,"code":"import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\nconst initialState = {\n  plans: [],\n  currentPlan: null,\n  readingSessions: [],\n  isLoading: false,\n  error: null\n};\nconst readingPlansAPI = {\n  getReadingPlans: async () => {\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    const plans = {\n      1: {\n        id: 1,\n        userId: 1,\n        bookId: 1,\n        title: 'Read The Bible in 90 Days',\n        startDate: new Date().toISOString(),\n        endDate: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString(),\n        totalPages: 1200,\n        currentPage: 120,\n        frequency: 'daily',\n        pagesPerSession: 14,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        book: {\n          title: 'The Bible',\n          author: 'Various Authors',\n          coverImageUrl: 'https://via.placeholder.com/150'\n        }\n      },\n      2: {\n        id: 2,\n        userId: 1,\n        bookId: 2,\n        title: 'Purpose Driven Life Study',\n        startDate: new Date().toISOString(),\n        endDate: new Date(Date.now() + 40 * 24 * 60 * 60 * 1000).toISOString(),\n        totalPages: 368,\n        currentPage: 45,\n        frequency: 'daily',\n        pagesPerSession: 10,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        book: {\n          title: 'The Purpose Driven Life',\n          author: 'Rick Warren',\n          coverImageUrl: 'https://via.placeholder.com/150'\n        }\n      }\n    };\n    return Object.values(plans);\n  },\n  getReadingPlanById: async planId => {\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    const plans = {\n      1: {\n        id: 1,\n        userId: 1,\n        bookId: 1,\n        title: 'Read The Bible in 90 Days',\n        startDate: new Date().toISOString(),\n        endDate: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString(),\n        totalPages: 1200,\n        currentPage: 120,\n        frequency: 'daily',\n        pagesPerSession: 14,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        book: {\n          title: 'The Bible',\n          author: 'Various Authors',\n          coverImageUrl: 'https://via.placeholder.com/150'\n        }\n      },\n      2: {\n        id: 2,\n        userId: 1,\n        bookId: 2,\n        title: 'Purpose Driven Life Study',\n        startDate: new Date().toISOString(),\n        endDate: new Date(Date.now() + 40 * 24 * 60 * 60 * 1000).toISOString(),\n        totalPages: 368,\n        currentPage: 45,\n        frequency: 'daily',\n        pagesPerSession: 10,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        book: {\n          title: 'The Purpose Driven Life',\n          author: 'Rick Warren',\n          coverImageUrl: 'https://via.placeholder.com/150'\n        }\n      }\n    };\n    const plan = plans[planId];\n    if (!plan) {\n      throw new Error('Reading plan not found');\n    }\n    return plan;\n  },\n  createReadingPlan: async planData => {\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    return Object.assign({\n      id: Math.floor(Math.random() * 1000),\n      userId: 1\n    }, planData, {\n      currentPage: 0,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      book: {\n        title: 'Newly Added Book',\n        author: 'Author Name'\n      }\n    });\n  },\n  updateReadingPlan: async planData => {\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    return {\n      id: planData.id,\n      userId: 1,\n      bookId: 1,\n      title: planData.title || 'Updated Reading Plan',\n      startDate: planData.startDate || new Date().toISOString(),\n      endDate: planData.endDate || new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),\n      totalPages: 300,\n      currentPage: planData.currentPage || 0,\n      frequency: planData.frequency || 'daily',\n      pagesPerSession: planData.pagesPerSession || 10,\n      notes: planData.notes,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      book: {\n        title: 'Sample Book',\n        author: 'Sample Author'\n      }\n    };\n  },\n  logReadingSession: async sessionData => {\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    const koachEarned = sessionData.pagesRead;\n    return {\n      id: Math.floor(Math.random() * 1000),\n      userId: 1,\n      bookId: sessionData.bookId,\n      readingPlanId: sessionData.readingPlanId || null,\n      pagesRead: sessionData.pagesRead,\n      minutesSpent: sessionData.minutesSpent || 0,\n      koachEarned,\n      notes: sessionData.notes,\n      createdAt: new Date().toISOString()\n    };\n  },\n  getReadingSessions: async () => {\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    return [{\n      id: 1,\n      userId: 1,\n      bookId: 1,\n      readingPlanId: 1,\n      pagesRead: 14,\n      minutesSpent: 30,\n      koachEarned: 14,\n      createdAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString()\n    }, {\n      id: 2,\n      userId: 1,\n      bookId: 1,\n      readingPlanId: 1,\n      pagesRead: 15,\n      minutesSpent: 35,\n      koachEarned: 15,\n      createdAt: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000).toISOString()\n    }, {\n      id: 3,\n      userId: 1,\n      bookId: 2,\n      readingPlanId: 2,\n      pagesRead: 10,\n      minutesSpent: 25,\n      koachEarned: 10,\n      createdAt: new Date().toISOString()\n    }];\n  }\n};\nexport const fetchReadingPlans = createAsyncThunk('readingPlans/fetchReadingPlans', async (_, {\n  rejectWithValue\n}) => {\n  try {\n    const plans = await readingPlansAPI.getReadingPlans();\n    return plans;\n  } catch (error) {\n    return rejectWithValue(error.message);\n  }\n});\nexport const fetchReadingPlanById = createAsyncThunk('readingPlans/fetchReadingPlanById', async (planId, {\n  rejectWithValue\n}) => {\n  try {\n    const plan = await readingPlansAPI.getReadingPlanById(planId);\n    return plan;\n  } catch (error) {\n    return rejectWithValue(error.message);\n  }\n});\nexport const createReadingPlan = createAsyncThunk('readingPlans/createReadingPlan', async (planData, {\n  rejectWithValue\n}) => {\n  try {\n    const plan = await readingPlansAPI.createReadingPlan(planData);\n    return plan;\n  } catch (error) {\n    return rejectWithValue(error.message);\n  }\n});\nexport const updateReadingPlan = createAsyncThunk('readingPlans/updateReadingPlan', async (planData, {\n  rejectWithValue\n}) => {\n  try {\n    const plan = await readingPlansAPI.updateReadingPlan(planData);\n    return plan;\n  } catch (error) {\n    return rejectWithValue(error.message);\n  }\n});\nexport const fetchReadingSessions = createAsyncThunk('readingPlans/fetchReadingSessions', async (_, {\n  rejectWithValue\n}) => {\n  try {\n    const sessions = await readingPlansAPI.getReadingSessions();\n    return sessions;\n  } catch (error) {\n    return rejectWithValue(error.message);\n  }\n});\nexport const logReadingSession = createAsyncThunk('readingPlans/logReadingSession', async (sessionData, {\n  rejectWithValue,\n  getState\n}) => {\n  try {\n    const session = await readingPlansAPI.logReadingSession(sessionData);\n    if (sessionData.readingPlanId) {\n      const state = getState();\n      const plan = state.readingPlans.plans.find(p => p.id === sessionData.readingPlanId);\n      if (plan) {\n        const updatedCurrentPage = plan.currentPage + sessionData.pagesRead;\n        return {\n          session,\n          planId: sessionData.readingPlanId,\n          updatedCurrentPage\n        };\n      }\n    }\n    return {\n      session\n    };\n  } catch (error) {\n    return rejectWithValue(error.message);\n  }\n});\nconst readingPlansSlice = createSlice({\n  name: 'readingPlans',\n  initialState,\n  reducers: {\n    clearReadingPlansError: state => {\n      state.error = null;\n    }\n  },\n  extraReducers: builder => {\n    builder.addCase(fetchReadingPlans.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(fetchReadingPlans.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.plans = action.payload;\n    }).addCase(fetchReadingPlans.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload || 'Failed to fetch reading plans';\n    }).addCase(fetchReadingPlanById.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(fetchReadingPlanById.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.currentPlan = action.payload;\n    }).addCase(fetchReadingPlanById.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload || 'Failed to fetch reading plan';\n    }).addCase(createReadingPlan.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(createReadingPlan.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.plans.push(action.payload);\n      state.currentPlan = action.payload;\n    }).addCase(createReadingPlan.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload || 'Failed to create reading plan';\n    }).addCase(updateReadingPlan.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(updateReadingPlan.fulfilled, (state, action) => {\n      state.isLoading = false;\n      const index = state.plans.findIndex(plan => plan.id === action.payload.id);\n      if (index !== -1) {\n        state.plans[index] = action.payload;\n      }\n      if (state.currentPlan && state.currentPlan.id === action.payload.id) {\n        state.currentPlan = action.payload;\n      }\n    }).addCase(updateReadingPlan.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload || 'Failed to update reading plan';\n    }).addCase(fetchReadingSessions.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(fetchReadingSessions.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.readingSessions = action.payload;\n    }).addCase(fetchReadingSessions.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload || 'Failed to fetch reading sessions';\n    }).addCase(logReadingSession.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(logReadingSession.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.readingSessions.unshift(action.payload.session);\n      if (action.payload.planId && action.payload.updatedCurrentPage !== undefined) {\n        const planIndex = state.plans.findIndex(plan => plan.id === action.payload.planId);\n        if (planIndex !== -1) {\n          state.plans[planIndex].currentPage = action.payload.updatedCurrentPage;\n          if (state.currentPlan && state.currentPlan.id === action.payload.planId) {\n            state.currentPlan.currentPage = action.payload.updatedCurrentPage;\n          }\n        }\n      }\n    }).addCase(logReadingSession.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload || 'Failed to log reading session';\n    });\n  }\n});\nexport const {\n  clearReadingPlansError\n} = readingPlansSlice.actions;\nexport const selectReadingPlans = state => state.readingPlans.plans;\nexport const selectCurrentPlan = state => state.readingPlans.currentPlan;\nexport const selectReadingSessions = state => state.readingPlans.readingSessions;\nexport const selectReadingPlansLoading = state => state.readingPlans.isLoading;\nexport const selectReadingPlansError = state => state.readingPlans.error;\nexport default readingPlansSlice.reducer;","map":{"version":3,"names":["createAsyncThunk","createSlice","initialState","plans","currentPlan","readingSessions","isLoading","error","readingPlansAPI","getReadingPlans","Promise","resolve","setTimeout","id","userId","bookId","title","startDate","Date","toISOString","endDate","now","totalPages","currentPage","frequency","pagesPerSession","createdAt","updatedAt","book","author","coverImageUrl","Object","values","getReadingPlanById","planId","plan","Error","createReadingPlan","planData","assign","Math","floor","random","updateReadingPlan","notes","logReadingSession","sessionData","koachEarned","pagesRead","readingPlanId","minutesSpent","getReadingSessions","fetchReadingPlans","_","rejectWithValue","message","fetchReadingPlanById","fetchReadingSessions","sessions","getState","session","state","readingPlans","find","p","updatedCurrentPage","readingPlansSlice","name","reducers","clearReadingPlansError","extraReducers","builder","addCase","pending","fulfilled","action","payload","rejected","push","index","findIndex","unshift","undefined","planIndex","actions","selectReadingPlans","selectCurrentPlan","selectReadingSessions","selectReadingPlansLoading","selectReadingPlansError","reducer"],"sources":["D:/All_Projects/Koach-Reader/client/src/slices/readingPlansSlice.ts"],"sourcesContent":["import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { RootState } from '../store';\nimport { Book } from './booksSlice';\n\n// Types\nexport interface ReadingPlan {\n  id: number;\n  userId: number;\n  bookId: number;\n  title: string;\n  startDate: string;\n  endDate: string;\n  totalPages: number;\n  currentPage: number;\n  frequency: 'daily' | 'weekly';\n  pagesPerSession: number;\n  notes?: string;\n  createdAt: string;\n  updatedAt: string;\n  book?: {\n    title: string;\n    author: string;\n    coverImageUrl?: string;\n  };\n}\n\nexport interface ReadingSession {\n  id: number;\n  userId: number;\n  bookId: number;\n  readingPlanId: number | null;\n  pagesRead: number;\n  minutesSpent: number;\n  koachEarned: number;\n  notes?: string;\n  createdAt: string;\n}\n\ninterface ReadingPlansState {\n  plans: ReadingPlan[];\n  currentPlan: ReadingPlan | null;\n  readingSessions: ReadingSession[];\n  isLoading: boolean;\n  error: string | null;\n}\n\ninterface CreatePlanData {\n  bookId: number;\n  title: string;\n  startDate: string;\n  endDate: string;\n  totalPages: number;\n  frequency: 'daily' | 'weekly';\n  pagesPerSession: number;\n  notes?: string;\n}\n\ninterface UpdatePlanData {\n  id: number;\n  title?: string;\n  startDate?: string;\n  endDate?: string;\n  currentPage?: number;\n  frequency?: 'daily' | 'weekly';\n  pagesPerSession?: number;\n  notes?: string;\n}\n\ninterface LogSessionData {\n  bookId: number;\n  readingPlanId?: number;\n  pagesRead: number;\n  minutesSpent?: number;\n  notes?: string;\n}\n\n// Initial state\nconst initialState: ReadingPlansState = {\n  plans: [],\n  currentPlan: null,\n  readingSessions: [],\n  isLoading: false,\n  error: null,\n};\n\n// Mock API functions (to be replaced with real API calls)\nconst readingPlansAPI = {\n  getReadingPlans: async (): Promise<ReadingPlan[]> => {\n    // Simulate API call delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    // Simulated reading plans data\n    const plans: { [key: number]: ReadingPlan } = {\n      1: {\n        id: 1,\n        userId: 1,\n        bookId: 1,\n        title: 'Read The Bible in 90 Days',\n        startDate: new Date().toISOString(),\n        endDate: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString(),\n        totalPages: 1200,\n        currentPage: 120,\n        frequency: 'daily',\n        pagesPerSession: 14,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        book: {\n          title: 'The Bible',\n          author: 'Various Authors',\n          coverImageUrl: 'https://via.placeholder.com/150',\n        },\n      },\n      2: {\n        id: 2,\n        userId: 1,\n        bookId: 2,\n        title: 'Purpose Driven Life Study',\n        startDate: new Date().toISOString(),\n        endDate: new Date(Date.now() + 40 * 24 * 60 * 60 * 1000).toISOString(),\n        totalPages: 368,\n        currentPage: 45,\n        frequency: 'daily',\n        pagesPerSession: 10,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        book: {\n          title: 'The Purpose Driven Life',\n          author: 'Rick Warren',\n          coverImageUrl: 'https://via.placeholder.com/150',\n        },\n      },\n    };\n    \n    return Object.values(plans);\n  },\n  \n  getReadingPlanById: async (planId: number): Promise<ReadingPlan> => {\n    // Simulate API call delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    // Simulated plan data\n    const plans: { [key: number]: ReadingPlan } = {\n      1: {\n        id: 1,\n        userId: 1,\n        bookId: 1,\n        title: 'Read The Bible in 90 Days',\n        startDate: new Date().toISOString(),\n        endDate: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString(),\n        totalPages: 1200,\n        currentPage: 120,\n        frequency: 'daily',\n        pagesPerSession: 14,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        book: {\n          title: 'The Bible',\n          author: 'Various Authors',\n          coverImageUrl: 'https://via.placeholder.com/150',\n        },\n      },\n      2: {\n        id: 2,\n        userId: 1,\n        bookId: 2,\n        title: 'Purpose Driven Life Study',\n        startDate: new Date().toISOString(),\n        endDate: new Date(Date.now() + 40 * 24 * 60 * 60 * 1000).toISOString(),\n        totalPages: 368,\n        currentPage: 45,\n        frequency: 'daily',\n        pagesPerSession: 10,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        book: {\n          title: 'The Purpose Driven Life',\n          author: 'Rick Warren',\n          coverImageUrl: 'https://via.placeholder.com/150',\n        },\n      },\n    };\n    \n    const plan = plans[planId];\n    \n    if (!plan) {\n      throw new Error('Reading plan not found');\n    }\n    \n    return plan;\n  },\n  \n  createReadingPlan: async (planData: CreatePlanData): Promise<ReadingPlan> => {\n    // Simulate API call delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    // Simulated API response\n    return {\n      id: Math.floor(Math.random() * 1000), // Simulated ID\n      userId: 1, // Assuming the current user's ID\n      ...planData,\n      currentPage: 0,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      book: {\n        title: 'Newly Added Book',\n        author: 'Author Name',\n      },\n    };\n  },\n  \n  updateReadingPlan: async (planData: UpdatePlanData): Promise<ReadingPlan> => {\n    // Simulate API call delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    // For simplicity, we'll return a mock updated plan\n    return {\n      id: planData.id,\n      userId: 1,\n      bookId: 1,\n      title: planData.title || 'Updated Reading Plan',\n      startDate: planData.startDate || new Date().toISOString(),\n      endDate: planData.endDate || new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),\n      totalPages: 300,\n      currentPage: planData.currentPage || 0,\n      frequency: planData.frequency || 'daily',\n      pagesPerSession: planData.pagesPerSession || 10,\n      notes: planData.notes,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      book: {\n        title: 'Sample Book',\n        author: 'Sample Author',\n      },\n    };\n  },\n  \n  logReadingSession: async (sessionData: LogSessionData): Promise<ReadingSession> => {\n    // Simulate API call delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    // Calculate Koach points (simple formula: 1 point per page)\n    const koachEarned = sessionData.pagesRead;\n    \n    // Simulated API response\n    return {\n      id: Math.floor(Math.random() * 1000), // Simulated ID\n      userId: 1, // Assuming the current user's ID\n      bookId: sessionData.bookId,\n      readingPlanId: sessionData.readingPlanId || null,\n      pagesRead: sessionData.pagesRead,\n      minutesSpent: sessionData.minutesSpent || 0,\n      koachEarned,\n      notes: sessionData.notes,\n      createdAt: new Date().toISOString(),\n    };\n  },\n  \n  getReadingSessions: async (): Promise<ReadingSession[]> => {\n    // Simulate API call delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    // Simulated reading sessions\n    return [\n      {\n        id: 1,\n        userId: 1,\n        bookId: 1,\n        readingPlanId: 1,\n        pagesRead: 14,\n        minutesSpent: 30,\n        koachEarned: 14,\n        createdAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),\n      },\n      {\n        id: 2,\n        userId: 1,\n        bookId: 1,\n        readingPlanId: 1,\n        pagesRead: 15,\n        minutesSpent: 35,\n        koachEarned: 15,\n        createdAt: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000).toISOString(),\n      },\n      {\n        id: 3,\n        userId: 1,\n        bookId: 2,\n        readingPlanId: 2,\n        pagesRead: 10,\n        minutesSpent: 25,\n        koachEarned: 10,\n        createdAt: new Date().toISOString(),\n      },\n    ];\n  },\n};\n\n// Async thunks\nexport const fetchReadingPlans = createAsyncThunk(\n  'readingPlans/fetchReadingPlans',\n  async (_, { rejectWithValue }) => {\n    try {\n      const plans = await readingPlansAPI.getReadingPlans();\n      return plans;\n    } catch (error: any) {\n      return rejectWithValue(error.message);\n    }\n  }\n);\n\nexport const fetchReadingPlanById = createAsyncThunk(\n  'readingPlans/fetchReadingPlanById',\n  async (planId: number, { rejectWithValue }) => {\n    try {\n      const plan = await readingPlansAPI.getReadingPlanById(planId);\n      return plan;\n    } catch (error: any) {\n      return rejectWithValue(error.message);\n    }\n  }\n);\n\nexport const createReadingPlan = createAsyncThunk(\n  'readingPlans/createReadingPlan',\n  async (planData: CreatePlanData, { rejectWithValue }) => {\n    try {\n      const plan = await readingPlansAPI.createReadingPlan(planData);\n      return plan;\n    } catch (error: any) {\n      return rejectWithValue(error.message);\n    }\n  }\n);\n\nexport const updateReadingPlan = createAsyncThunk(\n  'readingPlans/updateReadingPlan',\n  async (planData: UpdatePlanData, { rejectWithValue }) => {\n    try {\n      const plan = await readingPlansAPI.updateReadingPlan(planData);\n      return plan;\n    } catch (error: any) {\n      return rejectWithValue(error.message);\n    }\n  }\n);\n\nexport const fetchReadingSessions = createAsyncThunk(\n  'readingPlans/fetchReadingSessions',\n  async (_, { rejectWithValue }) => {\n    try {\n      const sessions = await readingPlansAPI.getReadingSessions();\n      return sessions;\n    } catch (error: any) {\n      return rejectWithValue(error.message);\n    }\n  }\n);\n\nexport const logReadingSession = createAsyncThunk(\n  'readingPlans/logReadingSession',\n  async (sessionData: LogSessionData, { rejectWithValue, getState }) => {\n    try {\n      const session = await readingPlansAPI.logReadingSession(sessionData);\n      \n      // If this session is part of a reading plan, we'll also need to update the plan's currentPage\n      if (sessionData.readingPlanId) {\n        const state = getState() as RootState;\n        const plan = state.readingPlans.plans.find(p => p.id === sessionData.readingPlanId);\n        \n        if (plan) {\n          const updatedCurrentPage = plan.currentPage + sessionData.pagesRead;\n          // In a real application, we would call an API to update the plan\n          // For now, we'll just include this information to be handled in the reducer\n          return { session, planId: sessionData.readingPlanId, updatedCurrentPage };\n        }\n      }\n      \n      return { session };\n    } catch (error: any) {\n      return rejectWithValue(error.message);\n    }\n  }\n);\n\n// Reading plans slice\nconst readingPlansSlice = createSlice({\n  name: 'readingPlans',\n  initialState,\n  reducers: {\n    // Any synchronous actions here\n    clearReadingPlansError: (state) => {\n      state.error = null;\n    },\n  },\n  extraReducers: (builder) => {\n    builder\n      // Fetch reading plans\n      .addCase(fetchReadingPlans.pending, (state) => {\n        state.isLoading = true;\n        state.error = null;\n      })\n      .addCase(fetchReadingPlans.fulfilled, (state, action: PayloadAction<ReadingPlan[]>) => {\n        state.isLoading = false;\n        state.plans = action.payload;\n      })\n      .addCase(fetchReadingPlans.rejected, (state, action) => {\n        state.isLoading = false;\n        state.error = action.payload as string || 'Failed to fetch reading plans';\n      })\n      // Fetch reading plan by ID\n      .addCase(fetchReadingPlanById.pending, (state) => {\n        state.isLoading = true;\n        state.error = null;\n      })\n      .addCase(fetchReadingPlanById.fulfilled, (state, action: PayloadAction<ReadingPlan>) => {\n        state.isLoading = false;\n        state.currentPlan = action.payload;\n      })\n      .addCase(fetchReadingPlanById.rejected, (state, action) => {\n        state.isLoading = false;\n        state.error = action.payload as string || 'Failed to fetch reading plan';\n      })\n      // Create reading plan\n      .addCase(createReadingPlan.pending, (state) => {\n        state.isLoading = true;\n        state.error = null;\n      })\n      .addCase(createReadingPlan.fulfilled, (state, action: PayloadAction<ReadingPlan>) => {\n        state.isLoading = false;\n        state.plans.push(action.payload);\n        state.currentPlan = action.payload;\n      })\n      .addCase(createReadingPlan.rejected, (state, action) => {\n        state.isLoading = false;\n        state.error = action.payload as string || 'Failed to create reading plan';\n      })\n      // Update reading plan\n      .addCase(updateReadingPlan.pending, (state) => {\n        state.isLoading = true;\n        state.error = null;\n      })\n      .addCase(updateReadingPlan.fulfilled, (state, action: PayloadAction<ReadingPlan>) => {\n        state.isLoading = false;\n        \n        // Update in plans array\n        const index = state.plans.findIndex(plan => plan.id === action.payload.id);\n        if (index !== -1) {\n          state.plans[index] = action.payload;\n        }\n        \n        // Update currentPlan if it's the same plan\n        if (state.currentPlan && state.currentPlan.id === action.payload.id) {\n          state.currentPlan = action.payload;\n        }\n      })\n      .addCase(updateReadingPlan.rejected, (state, action) => {\n        state.isLoading = false;\n        state.error = action.payload as string || 'Failed to update reading plan';\n      })\n      // Fetch reading sessions\n      .addCase(fetchReadingSessions.pending, (state) => {\n        state.isLoading = true;\n        state.error = null;\n      })\n      .addCase(fetchReadingSessions.fulfilled, (state, action: PayloadAction<ReadingSession[]>) => {\n        state.isLoading = false;\n        state.readingSessions = action.payload;\n      })\n      .addCase(fetchReadingSessions.rejected, (state, action) => {\n        state.isLoading = false;\n        state.error = action.payload as string || 'Failed to fetch reading sessions';\n      })\n      // Log reading session\n      .addCase(logReadingSession.pending, (state) => {\n        state.isLoading = true;\n        state.error = null;\n      })\n      .addCase(\n        logReadingSession.fulfilled,\n        (\n          state,\n          action: PayloadAction<{\n            session: ReadingSession;\n            planId?: number;\n            updatedCurrentPage?: number;\n          }>\n        ) => {\n          state.isLoading = false;\n          state.readingSessions.unshift(action.payload.session);\n          \n          // If this session was part of a reading plan, update the plan's currentPage\n          if (action.payload.planId && action.payload.updatedCurrentPage !== undefined) {\n            const planIndex = state.plans.findIndex(plan => plan.id === action.payload.planId);\n            if (planIndex !== -1) {\n              state.plans[planIndex].currentPage = action.payload.updatedCurrentPage;\n              \n              // Also update currentPlan if it's the same plan\n              if (state.currentPlan && state.currentPlan.id === action.payload.planId) {\n                state.currentPlan.currentPage = action.payload.updatedCurrentPage;\n              }\n            }\n          }\n        }\n      )\n      .addCase(logReadingSession.rejected, (state, action) => {\n        state.isLoading = false;\n        state.error = action.payload as string || 'Failed to log reading session';\n      });\n  },\n});\n\n// Export actions\nexport const { clearReadingPlansError } = readingPlansSlice.actions;\n\n// Export selectors\nexport const selectReadingPlans = (state: RootState) => state.readingPlans.plans;\nexport const selectCurrentPlan = (state: RootState) => state.readingPlans.currentPlan;\nexport const selectReadingSessions = (state: RootState) => state.readingPlans.readingSessions;\nexport const selectReadingPlansLoading = (state: RootState) => state.readingPlans.isLoading;\nexport const selectReadingPlansError = (state: RootState) => state.readingPlans.error;\n\n// Export reducer\nexport default readingPlansSlice.reducer;"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}