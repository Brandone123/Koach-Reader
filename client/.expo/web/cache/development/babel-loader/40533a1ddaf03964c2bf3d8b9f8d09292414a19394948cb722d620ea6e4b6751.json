{"ast":null,"code":"import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\nconst initialState = {\n  user: null,\n  token: null,\n  isLoading: false,\n  error: null\n};\nconst authAPI = {\n  login: async credentials => {\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    if (credentials.username === 'demo' && credentials.password === 'password') {\n      return {\n        user: {\n          id: 1,\n          username: 'demo',\n          email: 'demo@example.com',\n          isPremium: false,\n          koachPoints: 120,\n          readingStreak: 5,\n          preferences: {\n            readingFrequency: 'daily',\n            theme: 'light'\n          },\n          createdAt: new Date().toISOString()\n        },\n        token: 'mock-token-12345'\n      };\n    } else {\n      throw new Error('Invalid credentials');\n    }\n  },\n  register: async userData => {\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    if (userData.username === 'demo') {\n      throw new Error('Username already taken');\n    }\n    return {\n      user: {\n        id: 2,\n        username: userData.username,\n        email: userData.email,\n        isPremium: false,\n        koachPoints: 0,\n        readingStreak: 0,\n        preferences: {\n          readingFrequency: 'daily',\n          theme: 'light'\n        },\n        createdAt: new Date().toISOString(),\n        hasCompletedOnboarding: false\n      },\n      token: 'mock-token-67890'\n    };\n  },\n  updateProfile: async data => {\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    return {\n      id: 1,\n      username: data.username || 'demo',\n      email: data.email || 'demo@example.com',\n      isPremium: false,\n      koachPoints: 120,\n      readingStreak: 5,\n      preferences: data.preferences || {\n        readingFrequency: 'daily',\n        theme: 'light'\n      },\n      createdAt: new Date().toISOString()\n    };\n  }\n};\nexport const login = createAsyncThunk('auth/login', async (credentials, {\n  rejectWithValue\n}) => {\n  try {\n    const response = await authAPI.login(credentials);\n    return response;\n  } catch (error) {\n    return rejectWithValue(error.message);\n  }\n});\nexport const register = createAsyncThunk('auth/register', async (userData, {\n  rejectWithValue\n}) => {\n  try {\n    const response = await authAPI.register(userData);\n    return response;\n  } catch (error) {\n    return rejectWithValue(error.message);\n  }\n});\nexport const logout = createAsyncThunk('auth/logout', async () => {\n  return null;\n});\nexport const fetchCurrentUser = createAsyncThunk('auth/fetchCurrentUser', async (_, {\n  rejectWithValue\n}) => {\n  try {\n    return {\n      user: {\n        id: 1,\n        username: 'demo',\n        email: 'demo@example.com',\n        isPremium: false,\n        koachPoints: 120,\n        readingStreak: 5,\n        preferences: {\n          readingFrequency: 'daily',\n          theme: 'light'\n        },\n        createdAt: new Date().toISOString()\n      }\n    };\n  } catch (error) {\n    return rejectWithValue(error.message);\n  }\n});\nexport const updateProfile = createAsyncThunk('auth/updateProfile', async (profileData, {\n  rejectWithValue\n}) => {\n  try {\n    const user = await authAPI.updateProfile(profileData);\n    return {\n      user\n    };\n  } catch (error) {\n    return rejectWithValue(error.message);\n  }\n});\nexport const updatePreferences = createAsyncThunk('auth/updatePreferences', async (data, {\n  rejectWithValue\n}) => {\n  try {\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    return data.preferences;\n  } catch (error) {\n    return rejectWithValue(error instanceof Error ? error.message : 'Failed to update preferences');\n  }\n});\nconst authSlice = createSlice({\n  name: 'auth',\n  initialState,\n  reducers: {\n    clearError: state => {\n      state.error = null;\n    }\n  },\n  extraReducers: builder => {\n    builder.addCase(login.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(login.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.user = action.payload.user;\n      state.token = action.payload.token;\n    }).addCase(login.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload || 'Login failed';\n    }).addCase(register.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(register.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.user = action.payload.user;\n      state.token = action.payload.token;\n    }).addCase(register.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload || 'Registration failed';\n    }).addCase(logout.fulfilled, state => {\n      state.user = null;\n      state.token = null;\n    }).addCase(fetchCurrentUser.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(fetchCurrentUser.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.user = action.payload.user;\n    }).addCase(fetchCurrentUser.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload || 'Failed to fetch user';\n    }).addCase(updateProfile.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(updateProfile.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.user = action.payload.user;\n    }).addCase(updateProfile.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload || 'Failed to update profile';\n    }).addCase(updatePreferences.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(updatePreferences.fulfilled, (state, action) => {\n      state.isLoading = false;\n      if (state.user) {\n        state.user.preferences = action.payload;\n      }\n    }).addCase(updatePreferences.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload;\n    });\n  }\n});\nexport const {\n  clearError\n} = authSlice.actions;\nexport const selectUser = state => state.auth.user;\nexport const selectIsLoggedIn = state => !!state.auth.user;\nexport const selectIsLoading = state => state.auth.isLoading;\nexport const selectError = state => state.auth.error;\nexport const selectToken = state => state.auth.token;\nexport default authSlice.reducer;","map":{"version":3,"names":["createAsyncThunk","createSlice","initialState","user","token","isLoading","error","authAPI","login","credentials","Promise","resolve","setTimeout","username","password","id","email","isPremium","koachPoints","readingStreak","preferences","readingFrequency","theme","createdAt","Date","toISOString","Error","register","userData","hasCompletedOnboarding","updateProfile","data","rejectWithValue","response","message","logout","fetchCurrentUser","_","profileData","updatePreferences","authSlice","name","reducers","clearError","state","extraReducers","builder","addCase","pending","fulfilled","action","payload","rejected","actions","selectUser","auth","selectIsLoggedIn","selectIsLoading","selectError","selectToken","reducer"],"sources":["D:/All_Projects/Koach-Reader/client/src/slices/authSlice.ts"],"sourcesContent":["import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { RootState } from '../store';\n\n// Types\ninterface User {\n  id: number;\n  username: string;\n  email: string;\n  isPremium: boolean;\n  koachPoints: number;\n  readingStreak: number;\n  preferences?: {\n    readingFrequency?: 'daily' | 'weekly' | 'monthly';\n    ageRange?: 'child' | 'teen' | 'adult';\n    preferredCategories?: string[];\n    spiritualGoals?: string[];\n    preferredReadingFormat?: 'text' | 'audio';\n    preferredReadingTime?: string;\n    language?: string;\n    theme?: 'light' | 'dark' | 'system';\n  };\n  createdAt: string;\n  hasCompletedOnboarding?: boolean;\n}\n\ninterface AuthState {\n  user: User | null;\n  token: string | null;\n  isLoading: boolean;\n  error: string | null;\n}\n\ninterface LoginCredentials {\n  username: string;\n  password: string;\n}\n\ninterface RegisterData {\n  username: string;\n  email: string;\n  password: string;\n}\n\ninterface UpdateProfileData {\n  username?: string;\n  email?: string;\n  preferences?: User['preferences'];\n}\n\ninterface UpdatePreferencesData {\n  preferences: User['preferences'];\n}\n\n// Initial state\nconst initialState: AuthState = {\n  user: null,\n  token: null,\n  isLoading: false,\n  error: null,\n};\n\n// Mock API functions (to be replaced with real API calls)\nconst authAPI = {\n  login: async (credentials: LoginCredentials): Promise<{ user: User; token: string }> => {\n    // Simulate API call delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    // Simulated API response\n    if (credentials.username === 'demo' && credentials.password === 'password') {\n      return {\n        user: {\n          id: 1,\n          username: 'demo',\n          email: 'demo@example.com',\n          isPremium: false,\n          koachPoints: 120,\n          readingStreak: 5,\n          preferences: {\n            readingFrequency: 'daily',\n            theme: 'light',\n          },\n          createdAt: new Date().toISOString(),\n        },\n        token: 'mock-token-12345',\n      };\n    } else {\n      throw new Error('Invalid credentials');\n    }\n  },\n  \n  register: async (userData: RegisterData): Promise<{ user: User; token: string }> => {\n    // Simulate API call delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    // Check if username is taken (in a real app, this would be a server-side check)\n    if (userData.username === 'demo') {\n      throw new Error('Username already taken');\n    }\n    \n    // Simulated API response\n    return {\n      user: {\n        id: 2,\n        username: userData.username,\n        email: userData.email,\n        isPremium: false,\n        koachPoints: 0,\n        readingStreak: 0,\n        preferences: {\n          readingFrequency: 'daily',\n          theme: 'light',\n        },\n        createdAt: new Date().toISOString(),\n        hasCompletedOnboarding: false,\n      },\n      token: 'mock-token-67890',\n    };\n  },\n  \n  updateProfile: async (data: UpdateProfileData): Promise<User> => {\n    // Simulate API call delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    // Simulated API response - would update the user based on the provided data\n    return {\n      id: 1,\n      username: data.username || 'demo',\n      email: data.email || 'demo@example.com',\n      isPremium: false,\n      koachPoints: 120,\n      readingStreak: 5,\n      preferences: data.preferences || {\n        readingFrequency: 'daily',\n        theme: 'light',\n      },\n      createdAt: new Date().toISOString(),\n    };\n  },\n};\n\n// Async thunks\nexport const login = createAsyncThunk(\n  'auth/login',\n  async (credentials: LoginCredentials, { rejectWithValue }) => {\n    try {\n      const response = await authAPI.login(credentials);\n      return response;\n    } catch (error: any) {\n      return rejectWithValue(error.message);\n    }\n  }\n);\n\nexport const register = createAsyncThunk(\n  'auth/register',\n  async (userData: RegisterData, { rejectWithValue }) => {\n    try {\n      const response = await authAPI.register(userData);\n      return response;\n    } catch (error: any) {\n      return rejectWithValue(error.message);\n    }\n  }\n);\n\nexport const logout = createAsyncThunk('auth/logout', async () => {\n  // In a real app, you would call an API endpoint to invalidate the token\n  return null;\n});\n\nexport const fetchCurrentUser = createAsyncThunk(\n  'auth/fetchCurrentUser',\n  async (_, { rejectWithValue }) => {\n    try {\n      // In a real app, this would be a fetch to get the current user using the stored token\n      return {\n        user: {\n          id: 1,\n          username: 'demo',\n          email: 'demo@example.com',\n          isPremium: false,\n          koachPoints: 120,\n          readingStreak: 5,\n          preferences: {\n            readingFrequency: 'daily',\n            theme: 'light',\n          },\n          createdAt: new Date().toISOString(),\n        },\n      };\n    } catch (error: any) {\n      return rejectWithValue(error.message);\n    }\n  }\n);\n\nexport const updateProfile = createAsyncThunk(\n  'auth/updateProfile',\n  async (profileData: UpdateProfileData, { rejectWithValue }) => {\n    try {\n      const user = await authAPI.updateProfile(profileData);\n      return { user };\n    } catch (error: any) {\n      return rejectWithValue(error.message);\n    }\n  }\n);\n\nexport const updatePreferences = createAsyncThunk(\n  'auth/updatePreferences',\n  async (data: UpdatePreferencesData, { rejectWithValue }) => {\n    try {\n      // Simulate API call delay\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      \n      // Here you would make an actual API call to update preferences\n      // For now, we'll just return the updated preferences\n      return data.preferences;\n    } catch (error) {\n      return rejectWithValue(error instanceof Error ? error.message : 'Failed to update preferences');\n    }\n  }\n);\n\n// Auth slice\nconst authSlice = createSlice({\n  name: 'auth',\n  initialState,\n  reducers: {\n    // Add any synchronous actions here\n    clearError: (state) => {\n      state.error = null;\n    },\n  },\n  extraReducers: (builder) => {\n    builder\n      // Login\n      .addCase(login.pending, (state) => {\n        state.isLoading = true;\n        state.error = null;\n      })\n      .addCase(login.fulfilled, (state, action: PayloadAction<{ user: User; token: string }>) => {\n        state.isLoading = false;\n        state.user = action.payload.user;\n        state.token = action.payload.token;\n      })\n      .addCase(login.rejected, (state, action) => {\n        state.isLoading = false;\n        state.error = action.payload as string || 'Login failed';\n      })\n      // Register\n      .addCase(register.pending, (state) => {\n        state.isLoading = true;\n        state.error = null;\n      })\n      .addCase(register.fulfilled, (state, action: PayloadAction<{ user: User; token: string }>) => {\n        state.isLoading = false;\n        state.user = action.payload.user;\n        state.token = action.payload.token;\n      })\n      .addCase(register.rejected, (state, action) => {\n        state.isLoading = false;\n        state.error = action.payload as string || 'Registration failed';\n      })\n      // Logout\n      .addCase(logout.fulfilled, (state) => {\n        state.user = null;\n        state.token = null;\n      })\n      // Fetch current user\n      .addCase(fetchCurrentUser.pending, (state) => {\n        state.isLoading = true;\n        state.error = null;\n      })\n      .addCase(fetchCurrentUser.fulfilled, (state, action: PayloadAction<{ user: User }>) => {\n        state.isLoading = false;\n        state.user = action.payload.user;\n      })\n      .addCase(fetchCurrentUser.rejected, (state, action) => {\n        state.isLoading = false;\n        state.error = action.payload as string || 'Failed to fetch user';\n      })\n      // Update profile\n      .addCase(updateProfile.pending, (state) => {\n        state.isLoading = true;\n        state.error = null;\n      })\n      .addCase(updateProfile.fulfilled, (state, action: PayloadAction<{ user: User }>) => {\n        state.isLoading = false;\n        state.user = action.payload.user;\n      })\n      .addCase(updateProfile.rejected, (state, action) => {\n        state.isLoading = false;\n        state.error = action.payload as string || 'Failed to update profile';\n      })\n      // Update preferences\n      .addCase(updatePreferences.pending, (state) => {\n        state.isLoading = true;\n        state.error = null;\n      })\n      .addCase(updatePreferences.fulfilled, (state, action: PayloadAction<User['preferences']>) => {\n        state.isLoading = false;\n        if (state.user) {\n          state.user.preferences = action.payload;\n        }\n      })\n      .addCase(updatePreferences.rejected, (state, action) => {\n        state.isLoading = false;\n        state.error = action.payload as string;\n      });\n  },\n});\n\n// Export actions\nexport const { clearError } = authSlice.actions;\n\n// Export selectors\nexport const selectUser = (state: RootState) => state.auth.user;\nexport const selectIsLoggedIn = (state: RootState) => !!state.auth.user;\nexport const selectIsLoading = (state: RootState) => state.auth.isLoading;\nexport const selectError = (state: RootState) => state.auth.error;\nexport const selectToken = (state: RootState) => state.auth.token;\n\n// Export reducer\nexport default authSlice.reducer;"],"mappings":"AAAA,SAASA,gBAAgB,EAAEC,WAAW,QAAuB,kBAAkB;AAsD/E,MAAMC,YAAuB,GAAG;EAC9BC,IAAI,EAAE,IAAI;EACVC,KAAK,EAAE,IAAI;EACXC,SAAS,EAAE,KAAK;EAChBC,KAAK,EAAE;AACT,CAAC;AAGD,MAAMC,OAAO,GAAG;EACdC,KAAK,EAAE,MAAOC,WAA6B,IAA6C;IAEtF,MAAM,IAAIC,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,IAAI,CAAC,CAAC;IAGvD,IAAIF,WAAW,CAACI,QAAQ,KAAK,MAAM,IAAIJ,WAAW,CAACK,QAAQ,KAAK,UAAU,EAAE;MAC1E,OAAO;QACLX,IAAI,EAAE;UACJY,EAAE,EAAE,CAAC;UACLF,QAAQ,EAAE,MAAM;UAChBG,KAAK,EAAE,kBAAkB;UACzBC,SAAS,EAAE,KAAK;UAChBC,WAAW,EAAE,GAAG;UAChBC,aAAa,EAAE,CAAC;UAChBC,WAAW,EAAE;YACXC,gBAAgB,EAAE,OAAO;YACzBC,KAAK,EAAE;UACT,CAAC;UACDC,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;QACpC,CAAC;QACDrB,KAAK,EAAE;MACT,CAAC;IACH,CAAC,MAAM;MACL,MAAM,IAAIsB,KAAK,CAAC,qBAAqB,CAAC;IACxC;EACF,CAAC;EAEDC,QAAQ,EAAE,MAAOC,QAAsB,IAA6C;IAElF,MAAM,IAAIlB,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,IAAI,CAAC,CAAC;IAGvD,IAAIiB,QAAQ,CAACf,QAAQ,KAAK,MAAM,EAAE;MAChC,MAAM,IAAIa,KAAK,CAAC,wBAAwB,CAAC;IAC3C;IAGA,OAAO;MACLvB,IAAI,EAAE;QACJY,EAAE,EAAE,CAAC;QACLF,QAAQ,EAAEe,QAAQ,CAACf,QAAQ;QAC3BG,KAAK,EAAEY,QAAQ,CAACZ,KAAK;QACrBC,SAAS,EAAE,KAAK;QAChBC,WAAW,EAAE,CAAC;QACdC,aAAa,EAAE,CAAC;QAChBC,WAAW,EAAE;UACXC,gBAAgB,EAAE,OAAO;UACzBC,KAAK,EAAE;QACT,CAAC;QACDC,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;QACnCI,sBAAsB,EAAE;MAC1B,CAAC;MACDzB,KAAK,EAAE;IACT,CAAC;EACH,CAAC;EAED0B,aAAa,EAAE,MAAOC,IAAuB,IAAoB;IAE/D,MAAM,IAAIrB,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,IAAI,CAAC,CAAC;IAGvD,OAAO;MACLI,EAAE,EAAE,CAAC;MACLF,QAAQ,EAAEkB,IAAI,CAAClB,QAAQ,IAAI,MAAM;MACjCG,KAAK,EAAEe,IAAI,CAACf,KAAK,IAAI,kBAAkB;MACvCC,SAAS,EAAE,KAAK;MAChBC,WAAW,EAAE,GAAG;MAChBC,aAAa,EAAE,CAAC;MAChBC,WAAW,EAAEW,IAAI,CAACX,WAAW,IAAI;QAC/BC,gBAAgB,EAAE,OAAO;QACzBC,KAAK,EAAE;MACT,CAAC;MACDC,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;IACpC,CAAC;EACH;AACF,CAAC;AAGD,OAAO,MAAMjB,KAAK,GAAGR,gBAAgB,CACnC,YAAY,EACZ,OAAOS,WAA6B,EAAE;EAAEuB;AAAgB,CAAC,KAAK;EAC5D,IAAI;IACF,MAAMC,QAAQ,GAAG,MAAM1B,OAAO,CAACC,KAAK,CAACC,WAAW,CAAC;IACjD,OAAOwB,QAAQ;EACjB,CAAC,CAAC,OAAO3B,KAAU,EAAE;IACnB,OAAO0B,eAAe,CAAC1B,KAAK,CAAC4B,OAAO,CAAC;EACvC;AACF,CACF,CAAC;AAED,OAAO,MAAMP,QAAQ,GAAG3B,gBAAgB,CACtC,eAAe,EACf,OAAO4B,QAAsB,EAAE;EAAEI;AAAgB,CAAC,KAAK;EACrD,IAAI;IACF,MAAMC,QAAQ,GAAG,MAAM1B,OAAO,CAACoB,QAAQ,CAACC,QAAQ,CAAC;IACjD,OAAOK,QAAQ;EACjB,CAAC,CAAC,OAAO3B,KAAU,EAAE;IACnB,OAAO0B,eAAe,CAAC1B,KAAK,CAAC4B,OAAO,CAAC;EACvC;AACF,CACF,CAAC;AAED,OAAO,MAAMC,MAAM,GAAGnC,gBAAgB,CAAC,aAAa,EAAE,YAAY;EAEhE,OAAO,IAAI;AACb,CAAC,CAAC;AAEF,OAAO,MAAMoC,gBAAgB,GAAGpC,gBAAgB,CAC9C,uBAAuB,EACvB,OAAOqC,CAAC,EAAE;EAAEL;AAAgB,CAAC,KAAK;EAChC,IAAI;IAEF,OAAO;MACL7B,IAAI,EAAE;QACJY,EAAE,EAAE,CAAC;QACLF,QAAQ,EAAE,MAAM;QAChBG,KAAK,EAAE,kBAAkB;QACzBC,SAAS,EAAE,KAAK;QAChBC,WAAW,EAAE,GAAG;QAChBC,aAAa,EAAE,CAAC;QAChBC,WAAW,EAAE;UACXC,gBAAgB,EAAE,OAAO;UACzBC,KAAK,EAAE;QACT,CAAC;QACDC,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;MACpC;IACF,CAAC;EACH,CAAC,CAAC,OAAOnB,KAAU,EAAE;IACnB,OAAO0B,eAAe,CAAC1B,KAAK,CAAC4B,OAAO,CAAC;EACvC;AACF,CACF,CAAC;AAED,OAAO,MAAMJ,aAAa,GAAG9B,gBAAgB,CAC3C,oBAAoB,EACpB,OAAOsC,WAA8B,EAAE;EAAEN;AAAgB,CAAC,KAAK;EAC7D,IAAI;IACF,MAAM7B,IAAI,GAAG,MAAMI,OAAO,CAACuB,aAAa,CAACQ,WAAW,CAAC;IACrD,OAAO;MAAEnC;IAAK,CAAC;EACjB,CAAC,CAAC,OAAOG,KAAU,EAAE;IACnB,OAAO0B,eAAe,CAAC1B,KAAK,CAAC4B,OAAO,CAAC;EACvC;AACF,CACF,CAAC;AAED,OAAO,MAAMK,iBAAiB,GAAGvC,gBAAgB,CAC/C,wBAAwB,EACxB,OAAO+B,IAA2B,EAAE;EAAEC;AAAgB,CAAC,KAAK;EAC1D,IAAI;IAEF,MAAM,IAAItB,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,IAAI,CAAC,CAAC;IAIvD,OAAOoB,IAAI,CAACX,WAAW;EACzB,CAAC,CAAC,OAAOd,KAAK,EAAE;IACd,OAAO0B,eAAe,CAAC1B,KAAK,YAAYoB,KAAK,GAAGpB,KAAK,CAAC4B,OAAO,GAAG,8BAA8B,CAAC;EACjG;AACF,CACF,CAAC;AAGD,MAAMM,SAAS,GAAGvC,WAAW,CAAC;EAC5BwC,IAAI,EAAE,MAAM;EACZvC,YAAY;EACZwC,QAAQ,EAAE;IAERC,UAAU,EAAGC,KAAK,IAAK;MACrBA,KAAK,CAACtC,KAAK,GAAG,IAAI;IACpB;EACF,CAAC;EACDuC,aAAa,EAAGC,OAAO,IAAK;IAC1BA,OAAO,CAEJC,OAAO,CAACvC,KAAK,CAACwC,OAAO,EAAGJ,KAAK,IAAK;MACjCA,KAAK,CAACvC,SAAS,GAAG,IAAI;MACtBuC,KAAK,CAACtC,KAAK,GAAG,IAAI;IACpB,CAAC,CAAC,CACDyC,OAAO,CAACvC,KAAK,CAACyC,SAAS,EAAE,CAACL,KAAK,EAAEM,MAAoD,KAAK;MACzFN,KAAK,CAACvC,SAAS,GAAG,KAAK;MACvBuC,KAAK,CAACzC,IAAI,GAAG+C,MAAM,CAACC,OAAO,CAAChD,IAAI;MAChCyC,KAAK,CAACxC,KAAK,GAAG8C,MAAM,CAACC,OAAO,CAAC/C,KAAK;IACpC,CAAC,CAAC,CACD2C,OAAO,CAACvC,KAAK,CAAC4C,QAAQ,EAAE,CAACR,KAAK,EAAEM,MAAM,KAAK;MAC1CN,KAAK,CAACvC,SAAS,GAAG,KAAK;MACvBuC,KAAK,CAACtC,KAAK,GAAG4C,MAAM,CAACC,OAAO,IAAc,cAAc;IAC1D,CAAC,CAAC,CAEDJ,OAAO,CAACpB,QAAQ,CAACqB,OAAO,EAAGJ,KAAK,IAAK;MACpCA,KAAK,CAACvC,SAAS,GAAG,IAAI;MACtBuC,KAAK,CAACtC,KAAK,GAAG,IAAI;IACpB,CAAC,CAAC,CACDyC,OAAO,CAACpB,QAAQ,CAACsB,SAAS,EAAE,CAACL,KAAK,EAAEM,MAAoD,KAAK;MAC5FN,KAAK,CAACvC,SAAS,GAAG,KAAK;MACvBuC,KAAK,CAACzC,IAAI,GAAG+C,MAAM,CAACC,OAAO,CAAChD,IAAI;MAChCyC,KAAK,CAACxC,KAAK,GAAG8C,MAAM,CAACC,OAAO,CAAC/C,KAAK;IACpC,CAAC,CAAC,CACD2C,OAAO,CAACpB,QAAQ,CAACyB,QAAQ,EAAE,CAACR,KAAK,EAAEM,MAAM,KAAK;MAC7CN,KAAK,CAACvC,SAAS,GAAG,KAAK;MACvBuC,KAAK,CAACtC,KAAK,GAAG4C,MAAM,CAACC,OAAO,IAAc,qBAAqB;IACjE,CAAC,CAAC,CAEDJ,OAAO,CAACZ,MAAM,CAACc,SAAS,EAAGL,KAAK,IAAK;MACpCA,KAAK,CAACzC,IAAI,GAAG,IAAI;MACjByC,KAAK,CAACxC,KAAK,GAAG,IAAI;IACpB,CAAC,CAAC,CAED2C,OAAO,CAACX,gBAAgB,CAACY,OAAO,EAAGJ,KAAK,IAAK;MAC5CA,KAAK,CAACvC,SAAS,GAAG,IAAI;MACtBuC,KAAK,CAACtC,KAAK,GAAG,IAAI;IACpB,CAAC,CAAC,CACDyC,OAAO,CAACX,gBAAgB,CAACa,SAAS,EAAE,CAACL,KAAK,EAAEM,MAAqC,KAAK;MACrFN,KAAK,CAACvC,SAAS,GAAG,KAAK;MACvBuC,KAAK,CAACzC,IAAI,GAAG+C,MAAM,CAACC,OAAO,CAAChD,IAAI;IAClC,CAAC,CAAC,CACD4C,OAAO,CAACX,gBAAgB,CAACgB,QAAQ,EAAE,CAACR,KAAK,EAAEM,MAAM,KAAK;MACrDN,KAAK,CAACvC,SAAS,GAAG,KAAK;MACvBuC,KAAK,CAACtC,KAAK,GAAG4C,MAAM,CAACC,OAAO,IAAc,sBAAsB;IAClE,CAAC,CAAC,CAEDJ,OAAO,CAACjB,aAAa,CAACkB,OAAO,EAAGJ,KAAK,IAAK;MACzCA,KAAK,CAACvC,SAAS,GAAG,IAAI;MACtBuC,KAAK,CAACtC,KAAK,GAAG,IAAI;IACpB,CAAC,CAAC,CACDyC,OAAO,CAACjB,aAAa,CAACmB,SAAS,EAAE,CAACL,KAAK,EAAEM,MAAqC,KAAK;MAClFN,KAAK,CAACvC,SAAS,GAAG,KAAK;MACvBuC,KAAK,CAACzC,IAAI,GAAG+C,MAAM,CAACC,OAAO,CAAChD,IAAI;IAClC,CAAC,CAAC,CACD4C,OAAO,CAACjB,aAAa,CAACsB,QAAQ,EAAE,CAACR,KAAK,EAAEM,MAAM,KAAK;MAClDN,KAAK,CAACvC,SAAS,GAAG,KAAK;MACvBuC,KAAK,CAACtC,KAAK,GAAG4C,MAAM,CAACC,OAAO,IAAc,0BAA0B;IACtE,CAAC,CAAC,CAEDJ,OAAO,CAACR,iBAAiB,CAACS,OAAO,EAAGJ,KAAK,IAAK;MAC7CA,KAAK,CAACvC,SAAS,GAAG,IAAI;MACtBuC,KAAK,CAACtC,KAAK,GAAG,IAAI;IACpB,CAAC,CAAC,CACDyC,OAAO,CAACR,iBAAiB,CAACU,SAAS,EAAE,CAACL,KAAK,EAAEM,MAA0C,KAAK;MAC3FN,KAAK,CAACvC,SAAS,GAAG,KAAK;MACvB,IAAIuC,KAAK,CAACzC,IAAI,EAAE;QACdyC,KAAK,CAACzC,IAAI,CAACiB,WAAW,GAAG8B,MAAM,CAACC,OAAO;MACzC;IACF,CAAC,CAAC,CACDJ,OAAO,CAACR,iBAAiB,CAACa,QAAQ,EAAE,CAACR,KAAK,EAAEM,MAAM,KAAK;MACtDN,KAAK,CAACvC,SAAS,GAAG,KAAK;MACvBuC,KAAK,CAACtC,KAAK,GAAG4C,MAAM,CAACC,OAAiB;IACxC,CAAC,CAAC;EACN;AACF,CAAC,CAAC;AAGF,OAAO,MAAM;EAAER;AAAW,CAAC,GAAGH,SAAS,CAACa,OAAO;AAG/C,OAAO,MAAMC,UAAU,GAAIV,KAAgB,IAAKA,KAAK,CAACW,IAAI,CAACpD,IAAI;AAC/D,OAAO,MAAMqD,gBAAgB,GAAIZ,KAAgB,IAAK,CAAC,CAACA,KAAK,CAACW,IAAI,CAACpD,IAAI;AACvE,OAAO,MAAMsD,eAAe,GAAIb,KAAgB,IAAKA,KAAK,CAACW,IAAI,CAAClD,SAAS;AACzE,OAAO,MAAMqD,WAAW,GAAId,KAAgB,IAAKA,KAAK,CAACW,IAAI,CAACjD,KAAK;AACjE,OAAO,MAAMqD,WAAW,GAAIf,KAAgB,IAAKA,KAAK,CAACW,IAAI,CAACnD,KAAK;AAGjE,eAAeoC,SAAS,CAACoB,OAAO","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}