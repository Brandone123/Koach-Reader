{"ast":null,"code":"import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\nconst initialState = {\n  books: [],\n  userBooks: [],\n  currentBook: null,\n  bookComments: [],\n  isLoading: false,\n  error: null\n};\nconst booksAPI = {\n  getBooks: async params => {\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    const books = {\n      1: {\n        id: 1,\n        title: 'The Bible',\n        author: 'Various Authors',\n        description: 'The Bible is a collection of religious texts or scriptures sacred to Christians, Jews, Samaritans, and others.',\n        pageCount: 1200,\n        category: 'Religious',\n        language: 'English',\n        isPublic: true,\n        uploadedById: 1,\n        coverImageUrl: 'https://via.placeholder.com/150',\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n      },\n      2: {\n        id: 2,\n        title: 'The Purpose Driven Life',\n        author: 'Rick Warren',\n        description: 'The Purpose Driven Life is a devotional book written by Christian pastor Rick Warren and published by Zondervan.',\n        pageCount: 368,\n        category: 'Self-Help',\n        language: 'English',\n        isPublic: true,\n        uploadedById: 1,\n        coverImageUrl: 'https://via.placeholder.com/150',\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n      },\n      3: {\n        id: 3,\n        title: 'Mere Christianity',\n        author: 'C.S. Lewis',\n        description: 'Mere Christianity is a theological book by C.S. Lewis, adapted from a series of BBC radio talks.',\n        pageCount: 256,\n        category: 'Religious',\n        language: 'English',\n        isPublic: true,\n        uploadedById: 1,\n        coverImageUrl: 'https://via.placeholder.com/150',\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n      }\n    };\n    const filteredBooks = params.category ? Object.values(books).filter(book => book.category === params.category) : Object.values(books);\n    if (params.limit !== undefined && params.offset !== undefined) {\n      return filteredBooks.slice(params.offset, params.offset + params.limit);\n    }\n    return filteredBooks;\n  },\n  createBook: async bookData => {\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    return Object.assign({\n      id: 4\n    }, bookData, {\n      uploadedById: 1,\n      isPublic: bookData.isPublic ?? true,\n      language: bookData.language ?? 'English',\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString()\n    });\n  },\n  updateBook: async bookData => {\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    return {\n      id: bookData.id,\n      title: bookData.title || 'Updated Book',\n      author: bookData.author || 'Unknown Author',\n      description: bookData.description || 'No description available',\n      pageCount: bookData.pageCount || 100,\n      category: bookData.category || 'General',\n      language: bookData.language || 'English',\n      isPublic: bookData.isPublic ?? true,\n      uploadedById: 1,\n      fileUrl: bookData.fileUrl,\n      audioUrl: bookData.audioUrl,\n      coverImageUrl: bookData.coverImageUrl,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString()\n    };\n  },\n  addBookComment: async commentData => {\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    return {\n      id: Math.floor(Math.random() * 1000),\n      bookId: commentData.bookId,\n      userId: 1,\n      username: 'demo',\n      content: commentData.content,\n      rating: commentData.rating,\n      createdAt: new Date().toISOString()\n    };\n  }\n};\nexport const fetchBooks = createAsyncThunk('books/fetchBooks', async (_, {\n  rejectWithValue\n}) => {\n  try {\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    return booksAPI.getBooks({});\n  } catch (error) {\n    return rejectWithValue(error.message);\n  }\n});\nexport const fetchUserBooks = createAsyncThunk('books/fetchUserBooks', async (_, {\n  rejectWithValue\n}) => {\n  try {\n    const books = await booksAPI.getBooks({});\n    return books;\n  } catch (error) {\n    return rejectWithValue(error.message);\n  }\n});\nexport const fetchBookById = createAsyncThunk('books/fetchBookById', async (bookId, {\n  rejectWithValue\n}) => {\n  try {\n    const books = await booksAPI.getBooks({});\n    const book = books.find(b => b.id === bookId);\n    if (!book) {\n      throw new Error('Book not found');\n    }\n    return book;\n  } catch (error) {\n    return rejectWithValue(error.message);\n  }\n});\nexport const createBook = createAsyncThunk('books/createBook', async (bookData, {\n  rejectWithValue\n}) => {\n  try {\n    const book = await booksAPI.createBook(bookData);\n    return book;\n  } catch (error) {\n    return rejectWithValue(error.message);\n  }\n});\nexport const updateBook = createAsyncThunk('books/updateBook', async (bookData, {\n  rejectWithValue\n}) => {\n  try {\n    const book = await booksAPI.updateBook(bookData);\n    return book;\n  } catch (error) {\n    return rejectWithValue(error.message);\n  }\n});\nexport const fetchBookComments = createAsyncThunk('books/fetchBookComments', async (bookId, {\n  rejectWithValue\n}) => {\n  try {\n    return [{\n      id: 1,\n      bookId,\n      userId: 2,\n      username: 'user1',\n      content: 'This book changed my life!',\n      rating: 5,\n      createdAt: new Date().toISOString()\n    }, {\n      id: 2,\n      bookId,\n      userId: 3,\n      username: 'user2',\n      content: 'Very insightful read.',\n      rating: 4,\n      createdAt: new Date().toISOString()\n    }];\n  } catch (error) {\n    return rejectWithValue(error.message);\n  }\n});\nexport const addBookComment = createAsyncThunk('books/addBookComment', async (commentData, {\n  rejectWithValue\n}) => {\n  try {\n    const comment = await booksAPI.addBookComment(commentData);\n    return comment;\n  } catch (error) {\n    return rejectWithValue(error.message);\n  }\n});\nconst booksSlice = createSlice({\n  name: 'books',\n  initialState,\n  reducers: {\n    clearBooksError: state => {\n      state.error = null;\n    }\n  },\n  extraReducers: builder => {\n    builder.addCase(fetchBooks.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(fetchBooks.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.books = action.payload;\n    }).addCase(fetchBooks.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload || 'Failed to fetch books';\n    }).addCase(fetchUserBooks.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(fetchUserBooks.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.userBooks = action.payload;\n    }).addCase(fetchUserBooks.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload || 'Failed to fetch user books';\n    }).addCase(fetchBookById.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(fetchBookById.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.currentBook = action.payload;\n    }).addCase(fetchBookById.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload || 'Failed to fetch book';\n    }).addCase(createBook.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(createBook.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.books.push(action.payload);\n      state.userBooks.push(action.payload);\n    }).addCase(createBook.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload || 'Failed to create book';\n    }).addCase(updateBook.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(updateBook.fulfilled, (state, action) => {\n      state.isLoading = false;\n      const index = state.books.findIndex(book => book.id === action.payload.id);\n      if (index !== -1) {\n        state.books[index] = action.payload;\n      }\n      const userIndex = state.userBooks.findIndex(book => book.id === action.payload.id);\n      if (userIndex !== -1) {\n        state.userBooks[userIndex] = action.payload;\n      }\n      if (state.currentBook && state.currentBook.id === action.payload.id) {\n        state.currentBook = action.payload;\n      }\n    }).addCase(updateBook.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload || 'Failed to update book';\n    }).addCase(fetchBookComments.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(fetchBookComments.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.bookComments = action.payload;\n    }).addCase(fetchBookComments.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload || 'Failed to fetch comments';\n    }).addCase(addBookComment.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(addBookComment.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.bookComments.unshift(action.payload);\n    }).addCase(addBookComment.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload || 'Failed to add comment';\n    });\n  }\n});\nexport const {\n  clearBooksError\n} = booksSlice.actions;\nexport const selectBooks = state => state.books.books;\nexport const selectUserBooks = state => state.books.userBooks;\nexport const selectCurrentBook = state => state.books.currentBook;\nexport const selectBookComments = state => state.books.bookComments;\nexport const selectBooksLoading = state => state.books.isLoading;\nexport const selectBooksError = state => state.books.error;\nexport default booksSlice.reducer;","map":{"version":3,"names":["createAsyncThunk","createSlice","initialState","books","userBooks","currentBook","bookComments","isLoading","error","booksAPI","getBooks","params","Promise","resolve","setTimeout","id","title","author","description","pageCount","category","language","isPublic","uploadedById","coverImageUrl","createdAt","Date","toISOString","updatedAt","filteredBooks","Object","values","filter","book","limit","undefined","offset","slice","createBook","bookData","assign","updateBook","fileUrl","audioUrl","addBookComment","commentData","Math","floor","random","bookId","userId","username","content","rating","fetchBooks","_","rejectWithValue","message","fetchUserBooks","fetchBookById","find","b","Error","fetchBookComments","comment","booksSlice","name","reducers","clearBooksError","state","extraReducers","builder","addCase","pending","fulfilled","action","payload","rejected","push","index","findIndex","userIndex","unshift","actions","selectBooks","selectUserBooks","selectCurrentBook","selectBookComments","selectBooksLoading","selectBooksError","reducer"],"sources":["D:/All_Projects/Koach-Reader/client/src/slices/booksSlice.ts"],"sourcesContent":["import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { RootState } from '../store';\n\n// Types\nexport interface Book {\n  id: number;\n  title: string;\n  author: string;\n  description: string;\n  pageCount: number;\n  category: string;\n  language: string;\n  isPublic: boolean;\n  uploadedById: number;\n  fileUrl?: string;\n  audioUrl?: string;\n  coverImageUrl?: string;\n  createdAt: string;\n  updatedAt: string;\n}\n\ninterface Comment {\n  id: number;\n  bookId: number;\n  userId: number;\n  username: string;\n  content: string;\n  rating?: number;\n  createdAt: string;\n}\n\ninterface BooksState {\n  books: Book[];\n  userBooks: Book[];\n  currentBook: Book | null;\n  bookComments: Comment[];\n  isLoading: boolean;\n  error: string | null;\n}\n\ninterface GetBooksParams {\n  category?: string;\n  limit?: number;\n  offset?: number;\n}\n\ninterface CreateBookData {\n  title: string;\n  author: string;\n  description: string;\n  pageCount: number;\n  category: string;\n  language?: string;\n  isPublic?: boolean;\n  fileUrl?: string;\n  audioUrl?: string;\n  coverImageUrl?: string;\n}\n\ninterface UpdateBookData {\n  id: number;\n  title?: string;\n  author?: string;\n  description?: string;\n  pageCount?: number;\n  category?: string;\n  language?: string;\n  isPublic?: boolean;\n  fileUrl?: string;\n  audioUrl?: string;\n  coverImageUrl?: string;\n}\n\ninterface AddCommentData {\n  bookId: number;\n  content: string;\n  rating?: number;\n}\n\n// Initial state\nconst initialState: BooksState = {\n  books: [],\n  userBooks: [],\n  currentBook: null,\n  bookComments: [],\n  isLoading: false,\n  error: null,\n};\n\n// Mock API functions (to be replaced with real API calls)\nconst booksAPI = {\n  getBooks: async (params: GetBooksParams): Promise<Book[]> => {\n    // Simulate API call delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    // Simulated books data\n    const books: { [key: number]: Book } = {\n      1: {\n        id: 1,\n        title: 'The Bible',\n        author: 'Various Authors',\n        description: 'The Bible is a collection of religious texts or scriptures sacred to Christians, Jews, Samaritans, and others.',\n        pageCount: 1200,\n        category: 'Religious',\n        language: 'English',\n        isPublic: true,\n        uploadedById: 1,\n        coverImageUrl: 'https://via.placeholder.com/150',\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n      },\n      2: {\n        id: 2,\n        title: 'The Purpose Driven Life',\n        author: 'Rick Warren',\n        description: 'The Purpose Driven Life is a devotional book written by Christian pastor Rick Warren and published by Zondervan.',\n        pageCount: 368,\n        category: 'Self-Help',\n        language: 'English',\n        isPublic: true,\n        uploadedById: 1,\n        coverImageUrl: 'https://via.placeholder.com/150',\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n      },\n      3: {\n        id: 3,\n        title: 'Mere Christianity',\n        author: 'C.S. Lewis',\n        description: 'Mere Christianity is a theological book by C.S. Lewis, adapted from a series of BBC radio talks.',\n        pageCount: 256,\n        category: 'Religious',\n        language: 'English',\n        isPublic: true,\n        uploadedById: 1,\n        coverImageUrl: 'https://via.placeholder.com/150',\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n      },\n    };\n    \n    // Filter by category if specified\n    const filteredBooks = params.category\n      ? Object.values(books).filter(book => book.category === params.category)\n      : Object.values(books);\n    \n    // Apply pagination if specified\n    if (params.limit !== undefined && params.offset !== undefined) {\n      return filteredBooks.slice(params.offset, params.offset + params.limit);\n    }\n    \n    return filteredBooks;\n  },\n  \n  createBook: async (bookData: CreateBookData): Promise<Book> => {\n    // Simulate API call delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    // Simulated API response\n    return {\n      id: 4, // Simulated ID (in a real app, the server would assign this)\n      ...bookData,\n      uploadedById: 1, // Assuming the current user's ID\n      isPublic: bookData.isPublic ?? true,\n      language: bookData.language ?? 'English',\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n    };\n  },\n  \n  updateBook: async (bookData: UpdateBookData): Promise<Book> => {\n    // Simulate API call delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    // Simulated API response\n    // In a real app, we'd fetch the existing book and merge the updates\n    return {\n      id: bookData.id,\n      title: bookData.title || 'Updated Book',\n      author: bookData.author || 'Unknown Author',\n      description: bookData.description || 'No description available',\n      pageCount: bookData.pageCount || 100,\n      category: bookData.category || 'General',\n      language: bookData.language || 'English',\n      isPublic: bookData.isPublic ?? true,\n      uploadedById: 1,\n      fileUrl: bookData.fileUrl,\n      audioUrl: bookData.audioUrl,\n      coverImageUrl: bookData.coverImageUrl,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n    };\n  },\n  \n  addBookComment: async (commentData: AddCommentData): Promise<Comment> => {\n    // Simulate API call delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    // Simulated API response\n    return {\n      id: Math.floor(Math.random() * 1000), // Simulated ID\n      bookId: commentData.bookId,\n      userId: 1, // Assuming the current user's ID\n      username: 'demo', // Assuming the current user's username\n      content: commentData.content,\n      rating: commentData.rating,\n      createdAt: new Date().toISOString(),\n    };\n  },\n};\n\n// Async thunks\nexport const fetchBooks = createAsyncThunk(\n  'books/fetchBooks',\n  async (_, { rejectWithValue }) => {\n    try {\n      // Simulate API call delay\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      \n      // Simulated API response\n      return booksAPI.getBooks({});\n    } catch (error: any) {\n      return rejectWithValue(error.message);\n    }\n  }\n);\n\nexport const fetchUserBooks = createAsyncThunk(\n  'books/fetchUserBooks',\n  async (_, { rejectWithValue }) => {\n    try {\n      // In a real app, this would fetch books uploaded by the current user\n      const books = await booksAPI.getBooks({});\n      // Just return the same books for demo purposes\n      return books;\n    } catch (error: any) {\n      return rejectWithValue(error.message);\n    }\n  }\n);\n\nexport const fetchBookById = createAsyncThunk(\n  'books/fetchBookById',\n  async (bookId: number, { rejectWithValue }) => {\n    try {\n      // In a real app, this would be a specific API call to get a book by ID\n      const books = await booksAPI.getBooks({});\n      const book = books.find(b => b.id === bookId);\n      \n      if (!book) {\n        throw new Error('Book not found');\n      }\n      \n      return book;\n    } catch (error: any) {\n      return rejectWithValue(error.message);\n    }\n  }\n);\n\nexport const createBook = createAsyncThunk(\n  'books/createBook',\n  async (bookData: CreateBookData, { rejectWithValue }) => {\n    try {\n      const book = await booksAPI.createBook(bookData);\n      return book;\n    } catch (error: any) {\n      return rejectWithValue(error.message);\n    }\n  }\n);\n\nexport const updateBook = createAsyncThunk(\n  'books/updateBook',\n  async (bookData: UpdateBookData, { rejectWithValue }) => {\n    try {\n      const book = await booksAPI.updateBook(bookData);\n      return book;\n    } catch (error: any) {\n      return rejectWithValue(error.message);\n    }\n  }\n);\n\nexport const fetchBookComments = createAsyncThunk(\n  'books/fetchBookComments',\n  async (bookId: number, { rejectWithValue }) => {\n    try {\n      // In a real app, this would fetch comments for the specific book\n      // For demo purposes, we'll return mock data\n      return [\n        {\n          id: 1,\n          bookId,\n          userId: 2,\n          username: 'user1',\n          content: 'This book changed my life!',\n          rating: 5,\n          createdAt: new Date().toISOString(),\n        },\n        {\n          id: 2,\n          bookId,\n          userId: 3,\n          username: 'user2',\n          content: 'Very insightful read.',\n          rating: 4,\n          createdAt: new Date().toISOString(),\n        },\n      ];\n    } catch (error: any) {\n      return rejectWithValue(error.message);\n    }\n  }\n);\n\nexport const addBookComment = createAsyncThunk(\n  'books/addBookComment',\n  async (commentData: AddCommentData, { rejectWithValue }) => {\n    try {\n      const comment = await booksAPI.addBookComment(commentData);\n      return comment;\n    } catch (error: any) {\n      return rejectWithValue(error.message);\n    }\n  }\n);\n\n// Books slice\nconst booksSlice = createSlice({\n  name: 'books',\n  initialState,\n  reducers: {\n    // Any synchronous actions here\n    clearBooksError: (state) => {\n      state.error = null;\n    },\n  },\n  extraReducers: (builder) => {\n    builder\n      // Fetch books\n      .addCase(fetchBooks.pending, (state) => {\n        state.isLoading = true;\n        state.error = null;\n      })\n      .addCase(fetchBooks.fulfilled, (state, action: PayloadAction<Book[]>) => {\n        state.isLoading = false;\n        state.books = action.payload;\n      })\n      .addCase(fetchBooks.rejected, (state, action) => {\n        state.isLoading = false;\n        state.error = action.payload as string || 'Failed to fetch books';\n      })\n      // Fetch user books\n      .addCase(fetchUserBooks.pending, (state) => {\n        state.isLoading = true;\n        state.error = null;\n      })\n      .addCase(fetchUserBooks.fulfilled, (state, action: PayloadAction<Book[]>) => {\n        state.isLoading = false;\n        state.userBooks = action.payload;\n      })\n      .addCase(fetchUserBooks.rejected, (state, action) => {\n        state.isLoading = false;\n        state.error = action.payload as string || 'Failed to fetch user books';\n      })\n      // Fetch book by ID\n      .addCase(fetchBookById.pending, (state) => {\n        state.isLoading = true;\n        state.error = null;\n      })\n      .addCase(fetchBookById.fulfilled, (state, action: PayloadAction<Book>) => {\n        state.isLoading = false;\n        state.currentBook = action.payload;\n      })\n      .addCase(fetchBookById.rejected, (state, action) => {\n        state.isLoading = false;\n        state.error = action.payload as string || 'Failed to fetch book';\n      })\n      // Create book\n      .addCase(createBook.pending, (state) => {\n        state.isLoading = true;\n        state.error = null;\n      })\n      .addCase(createBook.fulfilled, (state, action: PayloadAction<Book>) => {\n        state.isLoading = false;\n        state.books.push(action.payload);\n        state.userBooks.push(action.payload);\n      })\n      .addCase(createBook.rejected, (state, action) => {\n        state.isLoading = false;\n        state.error = action.payload as string || 'Failed to create book';\n      })\n      // Update book\n      .addCase(updateBook.pending, (state) => {\n        state.isLoading = true;\n        state.error = null;\n      })\n      .addCase(updateBook.fulfilled, (state, action: PayloadAction<Book>) => {\n        state.isLoading = false;\n        \n        // Update in books array\n        const index = state.books.findIndex(book => book.id === action.payload.id);\n        if (index !== -1) {\n          state.books[index] = action.payload;\n        }\n        \n        // Update in userBooks array\n        const userIndex = state.userBooks.findIndex(book => book.id === action.payload.id);\n        if (userIndex !== -1) {\n          state.userBooks[userIndex] = action.payload;\n        }\n        \n        // Update currentBook if it's the same book\n        if (state.currentBook && state.currentBook.id === action.payload.id) {\n          state.currentBook = action.payload;\n        }\n      })\n      .addCase(updateBook.rejected, (state, action) => {\n        state.isLoading = false;\n        state.error = action.payload as string || 'Failed to update book';\n      })\n      // Fetch book comments\n      .addCase(fetchBookComments.pending, (state) => {\n        state.isLoading = true;\n        state.error = null;\n      })\n      .addCase(fetchBookComments.fulfilled, (state, action: PayloadAction<Comment[]>) => {\n        state.isLoading = false;\n        state.bookComments = action.payload;\n      })\n      .addCase(fetchBookComments.rejected, (state, action) => {\n        state.isLoading = false;\n        state.error = action.payload as string || 'Failed to fetch comments';\n      })\n      // Add book comment\n      .addCase(addBookComment.pending, (state) => {\n        state.isLoading = true;\n        state.error = null;\n      })\n      .addCase(addBookComment.fulfilled, (state, action: PayloadAction<Comment>) => {\n        state.isLoading = false;\n        state.bookComments.unshift(action.payload);\n      })\n      .addCase(addBookComment.rejected, (state, action) => {\n        state.isLoading = false;\n        state.error = action.payload as string || 'Failed to add comment';\n      });\n  },\n});\n\n// Export actions\nexport const { clearBooksError } = booksSlice.actions;\n\n// Export selectors\nexport const selectBooks = (state: RootState) => state.books.books;\nexport const selectUserBooks = (state: RootState) => state.books.userBooks;\nexport const selectCurrentBook = (state: RootState) => state.books.currentBook;\nexport const selectBookComments = (state: RootState) => state.books.bookComments;\nexport const selectBooksLoading = (state: RootState) => state.books.isLoading;\nexport const selectBooksError = (state: RootState) => state.books.error;\n\n// Export reducer\nexport default booksSlice.reducer;"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}